#+TITLE: phd-emacs - A GNU Emacs configuration
#+STARTUP: indent
#+OPTIONS: H:5 num:nil tags:nil toc:t timestamps:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

This is an emacs settings file using a literate programming style.
It is to be loaded in the [[./init.el][init.el]] (or .emacs) file using the org-babel library.


* Editor

Although having a bit trouble, installing Emacs on macOS, I finally managed
with Homebrew using the following command:

#+begin_src shell :exports none
  brew install --with-cocoa --with-ctags --with-gnutls --with-imagemagick emacs
#+end_src

However, installing Emacs with Homebrew can lead to instabilities later on,
which is why I later opted for compiling Emacs from source code myself is
ultimately the best solution on any OS. For details, go to
[[https://github.com/phdenzel/dotfiles/blob/master/installers/emacs_install.sh][https://github.com/phdenzel/dotfiles/blob/master/installers/emacs_install.sh]].

These days though, I usually work on linux machines, which facilitates
installing emacs immensely.

On debian-based distros, type

#+begin_src shell :exports none
  sudo apt install emacs
#+end_src

On Arch-based systems, use

#+begin_src shell :exports none
  sudo pacman -S emacs
#+end_src


* User specifics

User-specific information is hardcoded and has to be completed if it
is needed, e.g. for mail extensions (see solution for multiple email
accounts in the Mail section below).

#+begin_src emacs-lisp
  (setq user-full-name "Philipp Denzel")
  (setq user-mail-address "phdenzel@gmail.com")
#+end_src


* Security

Emacs is a versatile, modular, and simply great text editor.
It realises it's full potential by installing extensions through package.el.
However, this happens through 3-rd party archives such as ELPA, MELPA, etc.
usually over HTTP.
For details see:
https://glyph.twistedmatrix.com/2015/11/editor-malware.html
Here, steps are taken to increase security...

If it isn't installed already (should be on most distros though),
install 'certifi' via pip...

#+begin_src shell :tangle no
  python -m pip install --user certifi
#+end_src

GnuTLS ensures a secure handshake:

#+begin_src emacs-lisp
  (require 'cl-lib)
  (setq tls-checktrust t)

  (let ((trustfile
         (replace-regexp-in-string
          "\\\\" "/"
          (replace-regexp-in-string
           "\n" ""
           (shell-command-to-string "python -m certifi")))))
    (setq tls-program
          (list
           (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                   (if (eq window-system 'w32) ".exe" "") trustfile)))
    (setq gnutls-verify-error t)
    (setq gnutls-trustfiles (list trustfile)))

  ;; ;; Trust-No-One test
  ;; (let ((bad-hosts
  ;;        (cl-loop for bad
  ;;              in `("https://wrong.host.badssl.com/"
  ;;                   "https://self-signed.badssl.com/")
  ;;              if (condition-case e
  ;;                     (url-retrieve
  ;;                      bad (lambda (retrieved) t))
  ;;                   (error nil))
  ;;              collect bad)))
  ;;   (if bad-hosts
  ;;       (error (format "tls misconfigured; retrieved %s ok"
  ;;                      bad-hosts))
  ;;     (url-retrieve "https://badssl.com"
  ;;                   (lambda (retrieved) t))))
#+end_src


* Load packages with use-package

The Basic idea: instead of always going through a lengthy list of packages
and checking if they need to be installed at startup, 'use-package' is
employed to load the packages - if necessary also install them.
This is done after the initialization, and thus can increase the startup
substantially.
All packages should be loaded with 'use-package' (from straight.el).

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src


* Modules


** s

String manipulation module

#+begin_src emacs-lisp
  (use-package s)
#+end_src


** f

File system module

#+begin_src emacs-lisp
  (use-package f)
#+end_src


** dash

A modern list library for Emacs (required by the GitHub copilot package for instance)

#+begin_src emacs-lisp
  (use-package dash)
#+end_src


* Functions

Modified buffer splitting (don't load the same buffer when splitting frames)

#+begin_src emacs-lisp

  (defun phd/vsplit-last-buffer ()
    "Split the current buffer vertically and switch to the next."
    (interactive)
    (split-window-vertically)
    (other-window 1 nil)
    (switch-to-next-buffer))

  (defun phd/hsplit-last-buffer ()
    "Split the current buffer horizontally and switch to the next."
    (interactive)
    (split-window-horizontally)
    (other-window 1 nil)
    (switch-to-next-buffer))

#+end_src


Custom, interactive movement functions

#+begin_src emacs-lisp

  (defun phd/hydra-relinum/on ()
    "Activate relative line numbers in the current buffer."
    (interactive)
    (display-line-numbers-mode 1)
    (setq display-line-numbers 'relative))

  (defun phd/hydra-relinum/off ()
    "Deactivate relative line numbers in the current buffer."
    (interactive)
    (display-line-numbers-mode -1))

  (defun phd/hydra-nxtln (&optional arg)
    "Move cursor down ARG lines"
    (interactive "P")
    (setq this-command 'next-line)
    (next-line arg))

  (defun phd/hydra-prevln (&optional arg)
    "Move cursor up ARG lines"
    (interactive "P")
    (setq this-command 'previous-line)
    (previous-line arg))

  (defun phd/hydra-nxtchar (&optional arg)
    "Move cursor to the right by ARG characters"
    (interactive "P")
    (forward-char arg))

  (defun phd/hydra-prevchar (&optional arg)
    "Move cursor to the left by ARG characters"
    (interactive "P")
    (backward-char arg))

#+end_src


Evaluate & replace lisp code snippets, useful for scratch buffer math

#+begin_src emacs-lisp

  (defun phd/eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

#+end_src


A few useful functions that can be activated with Meta-x.

#+begin_src emacs-lisp

  (defun what-face (pos)
    "The name of the face at POS on which the cursor is currently placed."
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face
          (message "Face: %s" face)
        (message "No face at %d" pos))))

  (defun phd/iwb (&optional arg)
    "Indent the whole buffer. ARG for compatibility."
    (interactive "P")
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max)))

  (defun phd/nuke-all-buffers ()
    "Kill all buffers."
    (interactive)
    (mapc 'kill-buffer (buffer-list))
    (delete-other-windows))

#+end_src


#+begin_src emacs-lisp
  (defun phd/unfill-paragraph ()
    "Replace newline chars in current paragraph by single spaces.
  This command does the reverse of `fill-paragraph'."
    (interactive)
    (let ((fill-column 90002000))
      (fill-paragraph nil)))

  (defun phd/unfill-region (start end)
    "Replace newline chars in region by single spaces.
  This command does the reverse of `fill-region'."
    (interactive "r")
    (let ((fill-column 90002000))
      (fill-region start end)))
#+end_src


* Hydra, Ivy & Co.


** Hydras

The vast majority of packages are designed to speed up your workflow
by adding features which allow you to move inside a file more quickly
in one way or another.  Of course, this is almost always connected to
shortcuts, searches, or completions.  Here, hydra and associated
packages are configured. For more exemplary "hydras", see
[[https://github.com/abo-abo/hydra][https://github.com/abo-abo/hydra]].

#+begin_src emacs-lisp

    (defun phd/hydra-hint-toggle (name body)
      (interactive "P")
      (let ((cv (hydra-get-property name :verbosity)))
        (if (eq cv 2)
            (hydra-set-property name :verbosity 0)
          (hydra-set-property name :verbosity 2))
        body)
      )

#+end_src

#+begin_src emacs-lisp

  (use-package hydra
    :init
    (defhydra phd/hydra-toggler (:color pink)
      "toggle"
      ("a" abbrev-mode "abbrev")
      ("s" flyspell-mode "flyspell")
      ("f" auto-fill-mode "fill")
      ("x" rainbow-mode "rainbow")
      ("c" rainbow-delimiters-mode "rainbow-paren")
      ("w" whitespace-mode "whitespace")
      ("e" electric-indent-mode "indent")
      ("v" (phd/hydra-hint-toggle 'phd/hydra-toggler 'phd/hydra-toggler/body) "hint")
      ("h" help "help")
      ("q" nil "cancel")
      ("Q" nil)
      ("C-g" nil)
      ("C-x h" nil))
    (defhydra phd/hydra-goto-mv
      (:color pink :pre phd/hydra-relinum/on :post phd/hydra-relinum/off)
      "goto-mv"
      ("j" phd/hydra-nxtln "↓")
      ("k" phd/hydra-prevln "↑")
      ("l" phd/hydra-nxtchar "→")
      ("h" phd/hydra-prevchar "←")
      ("x" goto-line "goto-line")
      ("C-j" forward-paragraph "↓↓")
      ("C-k" backward-paragraph "↑↑")
      ("C-l" right-word "→→")
      ("C-h" left-word "←←")
      ("C-M-j" drag-stuff-down "drag-↓")
      ("C-M-k" drag-stuff-up "drag-↑")
      ("C-x l" next-buffer "buffer-→")
      ("C-x h" previous-buffer "buffer-←")
      ("a" back-to-indentation "←-line")
      ("e" move-end-of-line "→-line")
      ("r" recenter-top-bottom "recenter")
      ("s" swiper "swiper")
      ("d d" kill-line "kill-ln")
      (";" comment-dwim-2 "comment")
      ("SPC" set-mark-command "mark")
      ("w" kill-ring-save "save")
      ("y" yank "yank")
      ("g" keyboard-quit "quit")
      ("v" (phd/hydra-hint-toggle 'phd/hydra-goto-mv 'phd/hydra-goto-mv/body) "hint")
      ("q" nil "cancel")
      ("Q" nil)
      ("C-g" nil)
      ("C-x j" nil)
      ("C-x C-j" nil))
    (defhydra phd/hydra-flycheck (:color blue :hint none)
      "
      ^
      ^Flycheck^          ^Errors^            ^Checker^
      ^────────^──────────^──────^────────────^───────^─────
      _q_ quit            _<_ previous        _?_ describe
      _M_ manual          _>_ next            _d_ disable
      _!_ verify setup    _f_ check           _m_ mode
      ^^                  _l_ list            _s_ select
      _v_ hint            ^^                  ^^
      "
      ("q" nil)
      ("Q" nil)
      ("C-g" nil)
      ("<" flycheck-previous-error :color pink)
      (">" flycheck-next-error :color pink)
      ("?" flycheck-describe-checker)
      ("M" flycheck-manual)
      ("d" flycheck-disable-checker)
      ("f" flycheck-buffer)
      ("l" flycheck-list-errors)
      ("m" flycheck-mode)
      ("s" flycheck-select-checker)
      ("v" (phd/hydra-hint-toggle 'phd/hydra-flycheck 'phd/hydra-flycheck/body) :exit nil)
      ("!" flycheck-verify-setup))
    :config
    (hydra-set-property 'phd/hydra-toggler :verbosity 2)
    (hydra-set-property 'phd/hydra-goto-mv :verbosity 0))

#+end_src


** Ivy enhancements

We enhance the minibuffer completion with three packages:

- ~ivy~: a generic, efficient, and customizable completion mechanism
- ~counsel~: ivy-enhanced versions of common Emacs commands
- ~swiper~:  ivy-enhanced alternative to isearch


*** Ivy

#+begin_src emacs-lisp

  (use-package ivy-hydra
    :defer t
    :init (ivy-mode 1)
    :config (setq ivy-use-virtual-buffers t)
    )

#+end_src


*** Counsel

General ivy-minibuffer controls and common counsel command
replacements.  I typically search with lowercase letters only, and use
uppercase characters for ivy control.

#+begin_src emacs-lisp

  (use-package counsel
    :bind* (("M-x"     . counsel-M-x)
            ("M-y"     . counsel-yank-pop)
            ("C-x C-f" . counsel-find-file)
            ("C-x b"   . counsel-switch-buffer)
            ("C-x C-b" . counsel-ibuffer)
            ("C-c i u" . counsel-unicode-char)
            ("M-i"     . counsel-imenu)
            ("C-c g"   . counsel-git)
            ("C-c j"   . counsel-git-grep)
            ;;("C-c l"   . counsel-locate)
            :map ivy-minibuffer-map
            ("J"   . ivy-next-line)
            ("K"   . ivy-previous-line)
            ;;("C-j" . ivy-next-line)
            ;;("C-k" . ivy-previous-line)
            ("Q"   . minibuffer-keyboard-quit)
            ("C-q" . minibuffer-keyboard-quit)
            :map swiper-map
            ("Q" . minibuffer-keyboard-quit)
            ("C-q" . minibuffer-keyboard-quit))
    :config
    (define-key read-expression-map (kbd "C-r")
      #'counsel-expression-history)
    (ivy-set-actions
     'counsel-find-file
     '(("d" (lambda (x)
              (delete-file (expand-file-name x)))
        "delete")))
    (ivy-set-actions
     'ivy-switch-buffer
     '(("k" (lambda (x)
              (kill-buffer x)
              (ivy--reset-state ivy-last))
        "kill")
       ("j" ivy--switch-buffer-other-window-action
        "other window"))))

#+end_src


*** Swiper

#+begin_src emacs-lisp

  (use-package swiper
    :diminish ivy-mode
    :bind* ("C-s" . swiper))

#+end_src


** Avy

Ace-jump alternative, similar to vim-easymotion: enables jumping to
visible text using a char-based decision tree

#+begin_src emacs-lisp

  (use-package avy
    :bind
    ("M-s" . avy-goto-word-1))

#+end_src


** Ace-window

Hydra-enhanced window manager

#+begin_src emacs-lisp

  (use-package ace-window
    :defer t
    :bind ("C-x o" . ace-window)
    :config
    (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l)
          aw-dispatch-always t
          aw-dispatch-alist
          '((?x aw-delete-window "Ace - Delete Window")
            (?c aw-swap-window "Ace - Swap Window")
            (?n aw-flip-window "Ace - Flip Window")
            (?\- aw-split-window-vert "Ace - V-Split Window")
            (?\| aw-split-window-horz "Ace - H-Split Window")
            (?m delete-other-windows "Ace - Maximize Window")
            (?g delete-other-windows "Ace - Delete Window")
            (?b balance-windows "Ace - Balance Windows")
            (?v aw-show-dispatch-help)
            ;; ?w hydra-window-size/body
            ;; ?o hydra-window-scroll/body
            ;; ?\; hydra-window-frame/body
            ))
    ;; Window
    (defhydra hydra-window-size (:color red)
      "Windows size"
      ("h" shrink-window-horizontally "shrink horizontal")
      ("j" shrink-window "shrink vertical")
      ("k" enlarge-window "enlarge vertical")
      ("l" enlarge-window-horizontally "enlarge horizontal")
      ("q" nil "cancel" :exit t)
      ("Q" nil :exit t)
      ("C-g" nil :exit t))
    ;; Frame
    (defhydra hydra-window-frame (:color red)
      "Frame"
      ("f" make-frame "new frame")
      ("x" delete-frame "delete frame")
      ("q" nil "cancel" :exit t)
      ("Q" nil :exit t)
      ("C-g" nil :exit t))
    ;; Scrolling
    (defhydra hydra-window-scroll (:color red)
      "Scroll other window"
      ("n" scroll-other-window "scroll")
      ("p" scroll-other-window-down "scroll down")
      ("q" nil "cancel" :exit t)
      ("Q" nil :exit t)
      ("C-g" nil :exit t))
    ;; add to dispatch list
    (add-to-list
     'aw-dispatch-alist '(?w hydra-window-size/body) t)
    (add-to-list
     'aw-dispatch-alist '(?o hydra-window-scroll/body) t)
    (add-to-list
     'aw-dispatch-alist '(?\; hydra-window-frame/body) t)
  )

#+end_src


** Multiple cursors

#+begin_src emacs-lisp

  (use-package multiple-cursors
    :after hydra
    :bind (("M-SPC"         . set-rectangular-region-anchor)
           ("C-c ,"         . mc/edit-lines)
           ("C->"           . mc/mark-next-like-this)
           ("C-<"           . mc/mark-previous-like-this)
           ("C-c C-<"       . mc/mark-all-like-this)
           ("<C-M-mouse-1>" . mc/add-cursor-on-click)
           ("M-m"           . phd/hydra-mc/body))
    :init
    (defvar mc/cmds-to-run-for-all)
    (defvar mc/cmds-to-run-once)
    :config
    (defun phd/hydra-mc-exit ()
      "Exit hydra and disable multiple-cursors-mode"
      (interactive)
      (mc/keyboard-quit)
      (phd/hydra-mc/nil))
    (defhydra phd/hydra-mc (:color pink :hint none)
      "
      _N_ext           _P_revious^^          Miscellaneous           % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
      ------------------------------------------------------------------
      [_j_]^^ Next     [_k_]   Previous    [_l_] Edit lines  [_0_] Insert numbers
      [_J_]^^ Skip     [_K_]   Skip        [_a_] Mark all    [_I_] Insert letters
      [_M-j_] Unmark^^ [_M-k_] Unmark      [_s_] Search      [_q_] Quit
      [_|_]^^ Align with input CHAR^^      [_x_] Mark more   [Click] Cursor at point"
      ("l" mc/edit-lines)
      ("a" mc/mark-all-like-this-dwim :exit t)
      ("n" mc/mark-next-like-this)
      ("N" mc/skip-to-next-like-this)
      ("M-n" mc/unmark-next-like-this)
      ("p" mc/mark-previous-like-this)
      ("P" mc/skip-to-previous-like-this)
      ("M-p" mc/unmark-previous-like-this)
      ("j" mc/mark-next-lines)
      ("J" mc/skip-to-next-like-this)
      ("M-j" mc/unmark-next-like-this)
      ("k" mc/mark-previous-like-this)
      ("K" mc/skip-to-previous-like-this)
      ("M-k" mc/unmark-previous-like-this)
      ("|" mc/vertical-align)
      ("0" mc/insert-numbers :exit t)
      ("I" mc/insert-letters :exit t)
      ("s" mc/mark-all-in-region-regexp :exit t)
      ("r" mc/mark-sgml-tag-pair :exit t)
      ("x" mc/mark-more-like-this-extended)
      ("q" phd/hydra-mc-exit :exit t)
      ("Q" nil :exit t)
      ("C-g" phd/hydra-mc-exit :exit t)
      ("<mouse-1>" mc/add-cursor-on-click)
      ("<down-mouse-1>" ignore)
      ("<drag-mouse-1>" ignore)))

#+end_src


* Editing


** Sudo edit

Toggle sudo rights on an already opened file

#+begin_src emacs-lisp
  (use-package sudo-edit
    :bind ("C-c C-r" . sudo-edit))
#+end_src



** Comment

Do What I Mean when commenting

#+begin_src emacs-lisp

  (use-package comment-dwim-2
    :bind ("M-/" . comment-dwim-2))

#+end_src


** Delete

#+begin_src emacs-lisp

  (use-package hungry-delete
      :bind* (("C-<backspace>"   . hungry-delete-backward)
              ("C-M-<backspace>" . hungry-delete-backward)
              ("C-M-h"           . hungry-delete-backward)))

#+end_src


** Select

#+begin_src emacs-lisp

  (use-package expand-region
    :bind ("C-M-SPC" . er/expand-region))

#+end_src


** Drag

#+begin_src emacs-lisp

  (use-package drag-stuff
    :bind (("<C-M-up>"   . drag-stuff-up)
           ("<C-M-down>" . drag-stuff-down)))

#+end_src


** Complete

Modern auto-complete [*Comp*lete-*any*thing]

#+begin_src emacs-lisp

  (use-package company
    :defer 5
    :bind ("C-." . company-complete)
    :config
    (add-hook 'after-init-hook 'global-company-mode))

#+end_src


* Coding


** Language modes


*** Cython

#+begin_src emacs-lisp
  (use-package cython-mode)
#+end_src


*** Haskell

#+begin_src emacs-lisp

  (use-package haskell-mode
    :interpreter ("ghc" . haskell-mode))

#+end_src


*** Nix

#+begin_src emacs-lisp
  (use-package nix-mode)
#+end_src



*** Rust

#+begin_src emacs-lisp
  (use-package rust-mode)
#+end_src



*** Scala

#+begin_src emacs-lisp

  (use-package scala-mode
    :interpreter ("scala" . scala-mode))

#+end_src


*** Markdown

#+begin_src emacs-lisp

  (use-package markdown-mode
    :defer t
    :config
    (custom-set-variables '(markdown-command "/usr/bin/pandoc")))

#+end_src


*** YAML

#+begin_src emacs-lisp

  (use-package yaml-mode
    :defer t)

#+end_src


*** HTML

#+begin_src emacs-lisp

  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
    (setq web-mode-ac-sources-alist
          '(("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (defun my-web-mode-hook ()
      "Hooks for Web mode."
      (setq web-mode-enable-auto-closing t)
      (setq web-mode-enable-auto-quoting t)
      (setq web-mode-markup-indent-offset 2))
    (add-hook 'web-mode-hook 'my-web-mode-hook))

#+end_src


*** TODO Javascript

#+begin_src emacs-lisp

  (use-package js2-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode)))

#+end_src

For jsdoc, we first need to install a few dependencies

#+begin_src emacs-lisp :tangle no
  (use-package tree-sitter)
  (use-package tree-sitter-langs)
#+end_src

#+begin_src emacs-lisp :tangle no

  (use-package jsdoc
    ;;:quelpa (jsdoc
    ;;         :fetcher github
    ;;         :repo "isamert/jsdoc.el")
    :config
    :hook (js-mode . tree-sitter-mode)
    )

#+end_src


*** CSS & Co.

#+begin_src emacs-lisp

  (use-package less-css-mode
    :defer t)

#+end_src

#+begin_src emacs-lisp

  (use-package scss-mode
    :defer t
    :config (add-to-list 'auto-mode-alist '("\\.scss\\'" . scss-mode)))

#+end_src

#+begin_src emacs-lisp

  (use-package sass-mode
    :defer t
    :config (add-to-list 'auto-mode-alist '("\\.sass\\'" . sass-mode)))

#+end_src


** Dev envs


*** LSP

#+begin_src emacs-lisp
    (use-package lsp-mode
      :init
      (setq lsp-keymap-prefix "C-c l")
      :commands (lsp lsp-deferred)
      :hook (;; add all your lsp enabled languages here
             (python-mode . lsp)
             (nix-mode . lsp-deferred)
             (rust-mode . lsp)
             (lsp-mode . lsp-enable-which-key-integration))
      :config
      (setq lsp-pylsp-configuration-sources '("ruff")
            lsp-pylsp-plugins-ruff-enabled t
            lsp-pylsp-plugins-flake8-enabled nil
            lsp-pylsp-plugins-pycodestyle-enabled nil
            lsp-pylsp-rename-backend 'rope)
      )

#+end_src

#+begin_src emacs-lisp
  (use-package lsp-ui
    :commands lsp-ui-mode
    :disabled)
#+end_src


#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :after lsp-mode treemacs
    :commands (lsp-treemacs-errors-list lsp-treemacs-symbols)
    :bind (:map global-map
                ("C-M-s-:" . lsp-treemacs-symbols)
                ("C-M-s-;" . lsp-treemacs-errors-list))
    :config
    (lsp-treemacs-sync-mode 1)  ;; sync between treemacs
    (setq lsp-treemacs-deps-position-params
          '((side . right)
            (slot . 1)
            (window-width . 35)))
    (setq lsp-treemacs-symbols-position-params
          '((side . right)
            (slot . 2)
            (window-width . 35))))
#+end_src


*** Python

The ~elpy~ configuration will use these quoted variables

#+begin_src emacs-lisp :tangle no
  (setq python-shell-completion-native-enable t)
  (setq py-python-command "python3")
  (setq python-shell-interpreter "python3")
#+end_src


**** pyvenv

#+begin_src emacs-lisp
  (use-package pyvenv
    :config
    (setq pyvenv-workon "lsp")  ; Default virtualenv
    (pyvenv-workon pyvenv-workon)
    (when (fboundp 'pyvenv-track-virtualenv)
      (fmakunbound 'pyvenv-track-virtualenv)))
#+end_src


**** elpy (no tangle)

#+begin_src emacs-lisp :tangle no
  (use-package elpy
    :defer t
    :init
    (setq elpy-rpc-python-command python-shell-interpreter)
    (advice-add 'python-mode :before 'elpy-enable)
    :config
    (add-hook 'elpy-mode-hook
              (lambda () (highlight-indentation-mode -1)))
    (eval-after-load "elpy"
      '(cl-dolist (key '("M-<up>" "M-<down>" "M-<left>" "M-<right>"))
         (define-key elpy-mode-map (kbd key) nil)))
    (when (load "flycheck" t t)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode)))

#+end_src

Switch virtualenvs using ~M-x pyvenv-workon~. This requires exporting
the ~WORKON_HOME~ environment variable in your ~.bashrc~ (or
equivalent rc-file). By default, ~pipenv~ installs all its virtualenvs
in ~~/.local/share/virtualenvs~ and ~miniconda~ in ~/opt/miniconda3/envs~.

#+begin_src bash :tangle no
  export WORKON_HOME="/opt/miniconda3/envs"
#+end_src

Also be sure to install the necessary libraries via ~M-x pyvenv-create~
within emacs or manually via pip in the current virtualenv:

#+begin_src shell :tangle no
  pip install python-lsp-server[all] pylsp-rope pylsp-mypy python-lsp-black python-lsp-ruff
#+end_src


**** ein (emacs-ipython-notebook)

#+begin_src emacs-lisp

  (use-package ein
    :config
    (setq ein:output-area-inlined-images t))

#+end_src


**** company-jedi

#+begin_src emacs-lisp

  (use-package company-jedi
    :config
    (add-hook 'python-mode-hook 'jedi:setup)
    (setq jedi:complete-on-dot t)
    (setq jedi:use-shortcuts t)
    (defun phd/python-mode-hook ()
      (add-to-list 'company-backends 'company-jedi))
    (add-hook 'python-mode-hook 'phd/python-mode-hook))

#+end_src


*** Clojure

~cider~ extends emacs with support for interactive programming in
clojure

#+begin_src emacs-lisp

  (use-package cider
    :bind (:map cider-mode-map
                ("M-r" . cider-namespace-refresh))
    :config
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (add-hook 'cider-mode-hook #'cider-hydra-mode)
    (setq cider-repl-use-pretty-printing t)
    (setq cider-repl-display-help-banner nil))

#+end_src


*** Docker

Add support for Dockerfile editing

#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src


*** GitHub Copilot

Install dependencies first (s and dash are already installed)

#+begin_src emacs-lisp
  (use-package editorconfig)
#+end_src


#+begin_src emacs-lisp

  (use-package copilot
    :straight (:host github
               :repo "zerolfx/copilot.el"
               :files ("dist" "*.el"))
    :hook (prog-mode-hook . copilot-mode)
    :bind (:map copilot-mode-map
                ("<backtab>" . copilot-accept-completion-by-word)
                ("C-<tab>" . copilot-accept-completion)
                ("M-C-<next>" . copilot-next-completion)
                ("M-C-<prior>" . copilot-previous-completion)
                ("M-C-<right>" . copilot-accept-completion-by-word)
                ("M-C-<down>" . copilot-accept-completion-by-name))
    :after company
    :config
    (delq 'company-preview-if-just-one-frontend company-frontends))

#+end_src


*** ChatGPT (c3p0)

#+begin_src emacs-lisp
  (use-package c3po
    :straight (:host github :repo "d1egoaz/c3po.el")
    :after password-store
    :config
    (setq c3po-api-key (password-store-get-field "openai.com" "api-emacs")))
#+end_src


** Syntax helpers


*** flycheck

#+begin_src emacs-lisp

  (use-package flycheck
    :init
    (setq-default flycheck-flake8-maximum-line-length 99)
    (setq-default flycheck-disabled-checkers '(python-pylint))
    (global-flycheck-mode t))

#+end_src


** Utilities


*** highlight-parentheses

#+begin_src emacs-lisp

  (use-package highlight-parentheses
    :config (global-highlight-parentheses-mode))

#+end_src


*** rainbow-delimiters

#+begin_src emacs-lisp

  (use-package rainbow-delimiters)

#+end_src


*** rainbow-mode

#+begin_src emacs-lisp

  (use-package rainbow-mode)

#+end_src


*** yasnippets


Install snippet system

#+begin_src emacs-lisp

  (use-package yasnippet
    :config
    (setq yas-snippet-dirs '("~/.config/emacs/snippets"))
    (add-hook 'org-mode-hook #'yas-minor-mode)
    (add-hook 'web-mode-hook #'yas-minor-mode)
    (add-hook 'sh-mode-hook #'yas-minor-mode)
    (add-hook 'emacs-lisp-mode-hook #'yas-minor-mode)
    (add-hook 'haskell-mode-hook #'yas-minor-mode)
    (add-hook 'python-mode-hook #'yas-minor-mode)
    )

#+end_src

with some snippets

#+begin_src emacs-lisp

  (use-package yasnippet-snippets
    :after yasnippet
    :config
    (yas-reload-all))

#+end_src


** Project management


*** magit

#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-c m" . magit-status))
#+end_src


*** projectile

Often visited projects can be added to ~projectile~ with
~projectile-add-known-project~

#+begin_src emacs-lisp

  (use-package projectile
    :defer t
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map))
    :config    (setq projectile-known-projects-file "~/.config/emacs/projectile-bookmarks.eld")
    (setq projectile-completion-system 'ivy)
    (setq projectile-indexing-method 'alien)
    (projectile-mode t))

#+end_src

The counsel-extension adds a few more commands to the projectile
command map

#+begin_src emacs-lisp

  (use-package counsel-projectile
    :config
    (counsel-projectile-mode))

#+end_src


*** treemacs

#+begin_src emacs-lisp

  (use-package treemacs
    :bind
    (:map global-map
          ("C-M-:" . treemacs)
          ("C-M-;" . treemacs-select-window))
    :config
    (setq treemacs-width                 22
          treemacs-indentation           2
          treemacs-show-hidden-files     t
          treemacs-is-never-other-window t
          treemacs-position              'left
          treemacs-text-scale            -1
          treemacs-no-png-images         nil
          treemacs-litter-directories    '("/node_modules"
                                           "/.venv"
                                           "/.cask")
          )
    ;; (treemacs-resize-icons 16)
    )

#+end_src

#+begin_src emacs-lisp
  (use-package treemacs-magit
    :after treemacs magit)
#+end_src

#+begin_src emacs-lisp

  (use-package treemacs-projectile
    :after treemacs projectile)

#+end_src

#+begin_src emacs-lisp

  (use-package treemacs-all-the-icons
    :after treemacs all-the-icons
    :config
    (treemacs-load-theme "all-the-icons"))

#+end_src



* Markup


** htmlize

For converting source code to HTML. Especially nice for preserving syntax
colouring of org-mode src-blocks in exported HTML code.

#+begin_src emacs-lisp

  (use-package htmlize
    :defer t)

#+end_src


** org-mode


*** org

#+begin_src emacs-lisp

  (use-package org
    :straight nil
    :config
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq markdown-fontify-code-blocks-natively t)
    (define-key org-mode-map (kbd "C-c C-S-l") 'org-toggle-link-display)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell      . t)
       (haskell    . t)
       (python     . t)
       (dot        . t))))

#+end_src


**** org-bullets

#+begin_src emacs-lisp

  (use-package org-bullets
    :after org
    :commands (org-bullets-mode)
    :init
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

#+end_src


**** org-ref

#+begin_src emacs-lisp
  (use-package bibtex
    :straight nil)
#+end_src

#+begin_src emacs-lisp
  (use-package ivy-bibtex
    :bind
    (:map org-mode-map
          ("C-c C-b" . ivy-bibtex))
    :init
    ;; (autoload 'ivy-bibtex "ivy-bibtex" "" t)
    (setq ivy-re-builders-alist
          '((ivy-bibtex . ivy--regex-ignore-order)
            (t . ivy--regex-plus)))
    :config
    (setq bibtex-completion-bibliography '("~/zettelkasten/bib/master.bib"
                                           "~/zettelkasten/bib/astro_ph.bib"
                                           "~/zettelkasten/bib/corr.bib"
                                           "~/zettelkasten/bib/math.bib"
                                           "~/zettelkasten/bib/skach.bib"
                                           "~/zettelkasten/bib/gen4tng.bib"
                                           "~/zettelkasten/bib/trustworthy_ai.bib")
          bibtex-completion-library-path '("~/zettelkasten/pdf/")
          bibtex-completion-pdf-symbol "⌘"
          bibtex-completion-pdf-field "file"
          bibtex-completion-notes-path "~/zettelkasten/ref/"
          bibtex-completion-notes-symbol "✎"
          bibtex-completion-notes-template-multiple-files "* ${author-or-editor-abbrev} (${year}) - ${title}\n\nReference: [[cite:&${=key=}]]\n"
          bibtex-completion-display-formats
          '((article       . "${=has-pdf=:1}${=has-note=:1} ${=key=:16} ${=type=:9} ${author:16} ${year:4} ${title:44}")
            (inbook        . "${=has-pdf=:1}${=has-note=:1} ${=key=:16} ${=type=:9} ${author:16} ${year:4} ${title:44} Chpt. ${chapter:32}")
            (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${=key=:16} ${=type=:9} ${author:16} ${year:4} ${title:44} ${booktitle:32}")
            (t             . "${=has-pdf=:1}${=has-note=:1} ${=key=:16} ${=type=:9} ${author:16} ${year:4} ${title:44}"))
          bibtex-completion-format-citation-functions
          '((org-mode . bibtex-completion-format-citation-org-cite)
            (latex-mode . bibtex-completion-format-citation-cite)
            (markdown-mode . bibtex-completion-format-citation-pandoc-citeproc)
            (python-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
            (rst-mode . bibtex-completion-format-citation-sphinxcontrib-bibtex)
            (default . bibtex-completion-format-citation-default))
          )
    (defun bibtex-completion-find-pdf-in-library (key-or-entry &optional find-additional)
      "Searches the directories in `bibtex-completion-library-path' for a PDF whose name is composed of the BibTeX DOI plus `bibtex-completion-pdf-extension'.
      The path of the first matching PDF is returned.
      If FIND-ADDITIONAL is non-nil, the paths of all PDFs whose name
      starts with the BibTeX key and ends with
      `bibtex-completion-pdf-extension' are returned instead."
      (let* ((key (if (stringp key-or-entry)
                      key-or-entry
                    (bibtex-completion-get-value "=key=" key-or-entry)))
             (doi (if (stringp key-or-entry)
                      key-or-entry
                    (bibtex-completion-get-value "doi" key-or-entry)))
             (main-pdf (cl-loop
                        for dir in (-flatten bibtex-completion-library-path)
                        append (cl-loop
                                for ext in (-flatten bibtex-completion-pdf-extension)
                                collect (f-join dir (s-concat doi ext))))))
        (if find-additional
            (sort ; move main pdf on top of the list if needed
             (cl-loop
              for dir in (-flatten bibtex-completion-library-path)
              append (directory-files dir t
                                      (s-concat "^" (regexp-quote key)
                                                ".*\\("
                                                (mapconcat 'regexp-quote
                                                           (-flatten bibtex-completion-pdf-extension)
                                                           "\\|")
                                                "\\)$")))
             (lambda (x y)
               (and (member x main-pdf)
                    (not (member y main-pdf)))))
  	      (-flatten (-first 'f-file? main-pdf)))))

    (defun bibtex-completion-open-pdf-external (keys &optional fallback-action)
      (let ((bibtex-completion-pdf-open-function
             (lambda (fpath) (start-process "zathura" "*helm-bibtex-zathura*" "/usr/bin/zathura" fpath))))
        (bibtex-completion-open-pdf keys fallback-action)))

    (ivy-bibtex-ivify-action bibtex-completion-open-pdf-external ivy-bibtex-open-pdf-external)

    (ivy-add-actions
     'ivy-bibtex
     '(("P" ivy-bibtex-open-pdf-external "Open PDF file in external viewer (if present)")))
    )
#+end_src

#+begin_src emacs-lisp
  (use-package org-ref
    :bind
    (:map org-mode-map
          ("C-c b" . 'org-ref-insert-link))
    :init
    (require 'bibtex)
    (setq bibtex-autokey-year-length 2
          bibtex-autokey-name-year-separator ""
          bibtex-autokey-year-title-separator ""
          bibtex-autokey-titleword-separator ""
          bibtex-autokey-titlewords 0
          bibtex-autokey-titlewords-stretch 0
          bibtex-autokey-titleword-length 0)
    (require 'org-ref-ivy)
    (require 'org-ref-bibtex)
    (require 'org-ref-arxiv)
    (require 'org-ref-isbn)
    (require 'org-ref-scopus)
    (require 'doi-utils)
    ;; (require 'org-ref-wos)
    )

  (defun phd/bibtex-entry-from-arxiv-doi (doi &optional bibfile)
    "Insert and clean bibtex entry from a DOI "
    (interactive
     (list (read-string
            "DOI: "
            ;; now set initial input
            (doi-utils-maybe-doi-from-region-or-current-kill))))
    (unless bibfile
      (setq bibfile (completing-read "Bibfile: " (org-ref-possible-bibfiles))))
    ;; filter DOI for arxiv id
    (setq arxiv-id-from-doi
          (replace-regexp-in-string "[aA][rR][xX][iI][vV][.:]" ""
                                    (car (last (split-string doi "/")))))
    ;; add bibtex entry by arXiv ID if DOI is from arXiv, else by DOI
    (if (and (string-match-p "[aA][rR][xX][iI][vV][.:]" doi)
            (not (null arxiv-id-from-doi)))
        (save-window-excursion
          (with-current-buffer
              (find-file-noselect bibfile)
            (goto-char (point-min))
            (if (re-search-forward (concat arxiv-id-from-doi "\\_>") nil t)
                (message "arxiv:%s is already in this file" arxiv-id-from-doi)
              (goto-char (point-max))

              (when (not (looking-back "\n\n" (min 3 (point))))
                (insert "\n\n"))
              (arxiv-add-bibtex-entry arxiv-id-from-doi bibfile)
              (save-buffer))))
      (doi-add-bibtex-entry doi bibfile))
    )

  (defhydra+ org-ref-insert-link-hydra (:color red :hint nil)
    "Add arxiv entry from DOI to `org-ref-insert-link-hydra'."
    ("ba" phd/bibtex-entry-from-arxiv-doi "Add bibtex entry from arXiv DOI" :column "Bibtex"))
#+end_src

#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (setq pdf-view-use-scaling t)
    (if (file-directory-p "/opt/homebrew/bin")
        (setq pdf-info-epdfinfo-program "/opt/homebrew/bin/epdfinfo")
      (pdf-tools-install))
    )
#+end_src


**** org-roam

#+begin_src emacs-lisp

  (use-package org-roam
    :init
    (setq org-roam-directory (file-truename "~/zettelkasten")
          org-roam-database-connector 'sqlite-builtin
          org-roam-db-location "~/zettelkasten/org-roam.db"
          org-roam-db-gc-threshold most-positive-fixnum)
    (unless (file-exists-p org-roam-directory)
      (make-directory org-roam-directory t))
    ;;(org-roam-completion-everywhere t)
    :bind (("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ("C-c n g" . org-roam-graph)
           ("C-c n l" . org-roam-buffer-toggle)
           ("C-c n a" . org-roam-alias-add)
           ("C-c n r" . org-roam-ref-add)
           :map org-mode-map
           ("C-M-i"   . completion-at-point))
    :config
    (org-roam-db-autosync-mode)
    )

#+end_src


***** org-roam-bibtex

#+begin_src emacs-lisp

  (use-package org-roam-bibtex
    :after org-roam
    :init
    (add-hook 'org-mode-hook #'org-roam-bibtex-mode)
    :config
    (require 'org-ref)
    (setq orb-roam-ref-format 'org-ref-v3
          orb-preformat-keywords '("citekey" "author-or-editor-abbrev" "year" "author" "doi" "file")
          orb-process-file-keyword t
          orb-attached-file-extensions '("pdf"))
    (add-to-list 'org-roam-capture-templates
                 '("r" "bibliographic reference" plain
                   "%?"
                   :target (file+head "ref/${citekey}.org" "#+title: ${author-or-editor-abbrev} (${year})\n*Authors*: ${author}\n\n*DOI*: [[${doi}]]\n*PDF*: [[${file}]]\n\n* ${title}\n")
                   :unnarrowed t))
    )

#+end_src


***** org-roam-ui

#+begin_src emacs-lisp

  (use-package org-roam-ui
    :straight (:host github
               :repo "org-roam/org-roam-ui"
               :branch "main"
               :files ("*.el" "out"))
    :after org-roam
    ;; :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

#+end_src


**** TODO org-noter


**** org-id (customization)

#+begin_src emacs-lisp

  (use-package org-id
    :straight nil
    :config
    (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))

  (defun phd/org-custom-uid-get (&optional pom create prefix)
    "Get the CUSTOM_ID property of the entry at point-or-marker POM.
     If POM is nil, refer to the entry at point. If the entry does
     not have an CUSTOM_ID, the function returns nil. However, when
     CREATE is non nil, create a CUSTOM_ID if none is present
     already. PREFIX will be passed through to `org-id-new'. In any
     case, the CUSTOM_ID of the entry is returned."
    (interactive)
    (org-with-point-at pom
      (let ((id (org-entry-get nil "CUSTOM_ID")))
        (cond
         ((and id (stringp id) (string-match "\\S-" id))
          id)
         (create
          (setq id (org-id-new (concat prefix "h")))
          (org-entry-put pom "CUSTOM_ID" id)
          (org-id-add-location id (buffer-file-name (buffer-base-buffer)))
          id)))))

  (defun phd/org-add-uids-to-headlines-in-file ()
    "Add CUSTOM_ID properties to all headlines in the current
     file which do not already have one. Only adds ids if the
     `auto-id' option is set to `t' in the file somewhere, i.e.
     ,#+OPTIONS: auto-id:t"
    (interactive)
    (save-excursion
      (widen)
      (goto-char (point-min))
      (when (re-search-forward "^#\\+OPTIONS:.*auto-id:t" (point-max) t)
        (org-map-entries (lambda () (phd/org-custom-uid-get (point) 'create))))))

  ;; automatically add ids to saved org-mode headlines
  (add-hook 'org-mode-hook
            (lambda ()
              (add-hook 'before-save-hook
                        (lambda ()
                          (when (and (eq major-mode 'org-mode)
                                     (eq buffer-read-only nil))
                            (phd/org-add-uids-to-headlines-in-file))))))

  (setq org-latex-prefer-user-labels t)

  (defun create-custom-id-from-heading (heading)
    "Create a custom ID string from the given HEADING string.
     The custom ID is created by converting the heading to lowercase,
     substituting spaces for hyphens, and removing any non-alphanumeric characters."
    (replace-regexp-in-string "[^[:alnum:]]" "-" (downcase heading)))

  (defun prompt-for-custom-id ()
    "Prompt the user for a CUSTOM_ID property, using the current
     headline text as the default value."
    (interactive)
    (let ((headline (org-get-heading t t)))
      (org-set-property "CUSTOM_ID" (create-custom-id-from-heading headline))))

  (defun phd/org-custom-ids ()
    "Run through the current org mode document recursively, stopping at each heading
     and setting the CUSTOM_ID property based on the heading text."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-heading-regexp nil t)
        (prompt-for-custom-id)
        (outline-next-heading))))

#+end_src



**** org-reveal (deprecated)

#+begin_src emacs-lisp :tangle no

  (setq org-reveal-root (concat "file://" (expand-file-name "~/local/reveal.js")))
  (setq org-reveal-mathjax t)

#+end_src

**** org-reveal

#+begin_src emacs-lisp

  (use-package org-re-reveal
    :after org
    :config
    ;; (setq org-re-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")
    (setq org-re-reveal-root (concat "file://" (expand-file-name "~/local/reveal.js")))
    (setq org-re-reveal-mathjax t))

#+end_src


**** org-toc

#+begin_src emacs-lisp

  (use-package toc-org
    :after org
    :init
    (add-hook 'org-mode-hook 'toc-org-mode)
    ;; :config
    ;; (define-key markdown-mode-map (kbd "\C-c\C-o") 'toc-org-markdown-follow-thing-at-point)
    )

#+end_src



*** Exports

Automatically execute source code blocks during exports
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src


**** ox-md

#+begin_src emacs-lisp

  (use-package ox-md
    :straight nil
    :after org)

#+end_src


**** my-md

Custom markdown export backend with html-formatted src-block export when
marked with ~#+ATTR_MD: :language t~

#+begin_src emacs-lisp

  (defun my-md-src-block (src-block contents info)
    "Transcode a SRC-BLOCK element from Org to Markdown.
    CONTENTS is nil. INFO is a plist used as a communication
    channel."
    (if (not (org-export-read-attribute :attr_md src-block :language))
        (org-export-with-backend 'md src-block contents info)
      (org-export-with-backend 'html src-block contents info)))

  (org-export-define-derived-backend 'my-md 'md
    :translate-alist '((src-block . my-md-src-block)))

#+end_src

For now use ~M-:~ to evaluate

#+begin_src emacs-lisp :tangle no
  (org-export-to-buffer 'my-md "*Org MY-MD Export*")
#+end_src

this will create a buffer with the export which can be saved to file.


**** ox-gfm

#+begin_src emacs-lisp

  (use-package ox-gfm
    :after org)

#+end_src


**** ox-rst

#+begin_src emacs-lisp
  (use-package ox-rst
    :after org)
#+end_src


**** TODO Custom hooks

Convert custom canvas expression in org-export with backend ~html~ and
~reveal~

TODO:
- ‘beginning-of-buffer’ is for interactive use only; use ‘(goto-char
  (point-min))’ instead.
- ‘replace-regexp’ is for interactive use only; use
  ‘re-search-forward’ and ‘replace-match’ instead.

#+begin_src emacs-lisp :tangle no

  (defun org-export-canvas (backend)
    "Replace @canvas{descr|id} to <canvas> html text in current buffer"
    (when (or (equal backend 'html) (equal backend 'reveal))
      (save-excursion
        (beginning-of-buffer)
        (replace-regexp "\@canvas{{{\\(.*?\\)|\\(.*?\\)}}}"
                        "@@html:<canvas id=\"\\2\" width=\"100%\" height=\"100%\">\\1</canvas>@@"
                        ))))

  (add-hook 'org-export-before-parsing-hook 'org-export-canvas)

#+end_src


**** Custom links


***** Youtube embeddings

#+begin_src emacs-lisp

  (defvar yt-iframe-format
    ;; You may want to change your width and height.
    (concat "<iframe"
            " src=\"https://www.youtube.com/embed/%s?rel=0&amp;showinfo=0&amp;loop=1\""
            " width=\"%s\""
            " height=\"%s\""
            " allow=\"autoplay; encrypted-media\""
            " frameborder=\"0\""
            " allowfullscreen>%s</iframe>"))

  (org-link-set-parameters
   "yt"
   :follow (lambda (handle)
             (browse-url
              (concat "https://www.youtube.com/embed/"
                      handle)))
   :export (lambda (path desc backend)
             (let* ((f (split-string path ","))
                    (path (nth 0 f))
                    (yt-width (or (nth 1 f) "440"))
                    (yt-height (or (nth 2 f) "335"))
                    )
               (cl-case backend
                 (html (format yt-iframe-format
                               path yt-width yt-height (or desc "")))
                 (latex (format "\href{%s}{%s}"
                                path (or desc "video"))))))
   )


  ;; (org-add-link-type
  ;;  "yt"
  ;;  (lambda (handle)
  ;;    (browse-url
  ;;     (concat "https://www.youtube.com/embed/"
  ;;             handle)))
  ;;  (lambda (path desc backend)
  ;;    (let* ((f (split-string path ","))
  ;;           (path (nth 0 f))
  ;;           (yt-width (or (nth 1 f) "440"))
  ;;           (yt-height (or (nth 2 f) "335"))
  ;;           )
  ;;      (cl-case backend
  ;;        (html (format yt-iframe-format
  ;;                      path yt-width yt-height (or desc "")))
  ;;        (latex (format "\href{%s}{%s}"
  ;;                       path (or desc "video")))
  ;;        )
  ;;      )
  ;;    ))

#+end_src


***** Giphy embeddings

#+begin_src emacs-lisp

  (defvar giphy-iframe-format
    ;; You may want to change your width and height.
    (concat "<iframe"
            " src=\"https://giphy.com/embed/%s\""
            " width=\"%s\""
            " height=\"%s\""
            " frameborder=\"0\""
            " allowfullscreen>%s</iframe>"))

  (org-link-set-parameters
   "giphy"
   :follow (lambda (handle)
             (browse-url
              (concat "https://giphy.com/embed/"
                      handle)))
   :export (lambda (path desc backend)
             (let* ((f (split-string path ","))
                    (path (nth 0 f))
                    (giphy-width (or (nth 1 f) "440"))
                    (giphy-height (or (nth 2 f) "335"))
                    )
               (cl-case backend
                 (html (format giphy-iframe-format
                               path giphy-width giphy-height (or desc "")))
                 (latex (format "\href{%s}{%s}"
                                path (or desc "video"))))))
   )

  ;; (org-add-link-type
  ;;  "giphy"
  ;;  (lambda (handle)
  ;;    (browse-url
  ;;     (concat "https://giphy.com/embed/"
  ;;             handle)))
  ;;  (lambda (path desc backend)
  ;;    (let* ((f (split-string path ","))
  ;;           (path (nth 0 f))
  ;;           (giphy-width (or (nth 1 f) "440"))
  ;;           (giphy-height (or (nth 2 f) "335"))
  ;;           )
  ;;      (cl-case backend
  ;;        (html (format giphy-iframe-format
  ;;                      path giphy-width giphy-height (or desc "")))
  ;;        (latex (format "\href{%s}{%s}"
  ;;                       path (or desc "video")))
  ;;        )
  ;;      )
  ;;    ))

#+end_src


** LaTeX

AUCTeX is an integrated environment for writing input files for LaTeX

#+begin_src emacs-lisp

  (use-package auctex
    :defer t
    :defines (TeX-view-program-selection)
    :config
    (require 'tex)
    (TeX-global-PDF-mode t)
    (add-to-list 'TeX-view-program-selection
                 '(output-pdf "Zathura")))

#+end_src


* Shells


** exec-path

#+begin_src emacs-lisp
  (if (file-directory-p "/opt/homebrew/bin")
      (add-to-list 'exec-path "/opt/homebrew/bin")
    )
#+end_src

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src


** vterm

#+begin_src emacs-lisp

  (use-package vterm
    :commands vterm
    :defines (term-prompt-regexp
              vterm-shell
              vterm-max-scrollback)
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")
    (setq vterm-shell "bash")
    (setq vterm-max-scrollback 10000))

#+end_src


** TODO eshell


* Mail


** mu4e

#+begin_src emacs-lisp
  (use-package mu4e
    :straight nil
    :init
    (if (file-directory-p "/opt/homebrew/Cellar/mu")
        (add-to-list 'load-path "/opt/homebrew/Cellar/mu/1.10.8/share/emacs/site-lisp/mu/mu4e")
      (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e/"))
    :config
    (if (file-directory-p "/opt/homebrew/opt/mu/bin/mu")
        (setq mu4e-mu-binary "/opt/homebrew/opt/mu/bin/mu"))
    )

  (use-package phd-mu4e-setup
    :straight nil
    :after mu4e
    :load-path "~/local/phd-mu4e-setup/"
    :bind (("C-x m"   . mu4e)
           ("C-x C-m" . mu4e-compose-new)
           ("C-x M-m" . mu4e-update-mail-and-index)))

#+end_src


** Password management

Use UNIX pass instead of authinfo (but keep other methods as backup)

#+begin_src emacs-lisp

  (use-package pass
    :config
    (setf epg-pinentry-mode 'loopback)
    (auth-source-pass-enable)
    (setq auth-sources '(password-store "~/.authinfo.gpg" "~/.authinfo" "~/.netrc")))

#+end_src

#+begin_src emacs-lisp

  (use-package password-store)

#+end_src

#+begin_src emacs-lisp

  (use-package auth-source-xoauth2)

#+end_src


** org-mime

Use org-mode to write html content in mails

#+begin_src emacs-lisp

  (use-package org-mime
    :hook ((message-mode . (lambda ()
                             (local-set-key (kbd "C-c M-o") 'org-mime-htmlize)))
           (org-mode . (lambda ()
                         (local-set-key (kbd "C-c M-o") 'org-mime-org-buffer-htmlize))))
    :config
    (setq org-mime-export-options '(:section-numbers nil
                                    :with-author nil
                                    :with-toc nil)))

#+end_src


* Helpers

Settings for a few helping features.


** which-key

#+begin_src emacs-lisp

  (use-package which-key
    :diminish which-key-mode
    :config (which-key-mode))

#+end_src


** company-quickhelp

#+begin_src emacs-lisp :tangle no

  (use-package company-quickhelp
    :config
    (eval-after-load 'company
      '(define-key company-active-map
         (kbd "C-c h")
         #'company-quickhelp-manual-begin)))

#+end_src


* Basic settings

Here, some default quirks of Emacs are corrected, to make it behave
like we want it to. These settings modify the general behaviour and
take global effect.


** Behaviour


*** Miscellaneous settings

#+begin_src emacs-lisp

  ;; Startup screen
  (setq inhibit-startup-message t)

  ;; Ask for y/n instead of yes/no
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; For orientation
  (global-hl-line-mode t)

  ;; Increase max. subprocess read size for better performance (in LSP)
  ;; default was 4K -> 1G
  (setq read-process-output-max (* 1024 1024))

  ;; Buffer sorting behaviour
  (setq Buffer-menu-use-frame-buffer-list nil)

#+end_src


*** Dired

#+begin_src emacs-lisp

  (put 'dired-find-alternate-file 'disabled nil)

#+end_src


*** Brackets

#+begin_src emacs-lisp

  ;; highlight pair
  (show-paren-mode t)

  ;; auto-close brackets
  (electric-pair-mode t)
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (add-hook
   'org-mode-hook
   (lambda ()
     (setq-local electric-pair-inhibit-predicate
                 `(lambda (c) (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))

#+end_src


*** Clipboard

#+begin_src emacs-lisp

  (setq select-enable-clipboard t
        select-enable-primary t
        save-interprogram-paste-before-kill t
        require-final-newline t)

#+end_src


*** Tabs

#+begin_src emacs-lisp

  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
  (setq indent-line-function 'insert-tab)
  (electric-indent-mode t)

#+end_src


*** Unique buffers

#+begin_src  emacs-lisp

  (if (< emacs-major-version 25)
      (require 'uniquify))
  (setq uniquify-buffer-name-style 'forward)

#+end_src


*** Mouse-wheel speed

#+begin_src emacs-lisp

  (setq mouse-wheel-scroll-amount '(1 ((shift) . 4) ((meta)) ((control)) ))
  (setq mouse-wheel-progressive-speed nil)

#+end_src


*** Silence bell

#+begin_src emacs-lisp

  (defun phd-bell ())
  (setq ring-bell-function 'phd-bell
        visible-bell nil)

#+end_src


** Keyboard shortcuts

Regular remaps and bindings

#+begin_src emacs-lisp

  ;; Reload buffer
  (global-set-key (kbd "<f5>") 'revert-buffer)

  ;; Kill current buffer instead of any buffer
  (global-set-key (kbd "C-x k") 'kill-this-buffer)

  ;; Go back to indentation instead of beginning of line
  (global-set-key (kbd "C-a") 'back-to-indentation)

  ;; Efficiently move up or down
  (global-set-key (kbd "<M-up>") 'backward-paragraph)
  (global-set-key (kbd "<M-down>") 'forward-paragraph)

  ;; Expand
  (global-set-key (kbd "M-.") 'hippie-expand)

  ;; other window
  (global-set-key (kbd "C-M-'") 'other-window)

#+end_src


Dired bindings

#+begin_src emacs-lisp

  ;; evil movement
  (define-key dired-mode-map "j" 'dired-next-line)
  (define-key dired-mode-map "k" 'dired-previous-line)
  (define-key dired-mode-map "h" 'left-char)
  (define-key dired-mode-map "l" 'right-char)
  ;; change behaviour of Enter -> a (doesn't open in new buffer)
  (define-key dired-mode-map (kbd "<return>") 'dired-find-alternate-file)
  ;; (define-key dired-mode-map "a" 'dired-find-file)

#+end_src


Binding custom functions and hydras

#+begin_src emacs-lisp

  ;; Modified vertical/horizontal buffer splits
  (global-set-key (kbd "C-x 2") 'phd/vsplit-last-buffer)
  (global-set-key (kbd "C-x 3") 'phd/hsplit-last-buffer)

  ;; Indent the entire buffer
  (global-set-key (kbd "C-c <tab>") 'phd/iwb)

  ;; Evaluate/replace lisp code... useful for scratch buffer math
  (global-set-key (kbd "C-c C-e") 'phd/eval-and-replace)
  (define-key lisp-interaction-mode-map (kbd "C-c e") 'eval-print-last-sexp)

  ;; Hydra bindings
  (global-set-key (kbd "C-x h")   'phd/hydra-toggler/body)
  (global-set-key (kbd "C-x j")   'phd/hydra-goto-mv/body)
  (global-set-key (kbd "C-x C-j") 'phd/hydra-goto-mv/body)
  (global-set-key (kbd "C-c f")   'phd/hydra-flycheck/body)

  (define-key org-mode-map (kbd "C-c r") 'org-ref-citation-hydra/body)
  (define-key org-mode-map (kbd "C-c C-r") 'org-ref-insert-link-hydra/body)
  (define-key bibtex-mode-map (kbd "C-c r") 'org-ref-bibtex-hydra/body)
  (define-key bibtex-mode-map (kbd "C-c C-r") 'org-ref-insert-link-hydra/body)

#+end_src


** System language settings

Prefer UTF-8 encodings

#+begin_src emacs-lisp

  ;; Prefer UTF-8
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (setq locale-coding-system 'utf-8)

#+end_src


Configure ispell spell checker which comes bundled with emacs by
default since v24. It can use multiple programs:
- ~aspell~ should be on most Linux systems, but seems to be no longer
  maintained
- ~hunspell~ is widely used, but has inferior capabilities

#+begin_src emacs-lisp

  (use-package ispell
    :init
    (setq ispell-program-name "/usr/bin/aspell")
    :config
    (when (executable-find "hunspell")
      (setq-default ispell-program-name "hunspell")))

#+end_src


** Backup behaviour

The default backup behaviour of emacs is quite annoying, as it
duplicates/spams local folders. I much rather have emacs gather them
in a dedicated directory.

#+begin_src emacs-lisp

  ;; collect them in .config/emacs/backups
  (defvar phd-backup-directory "~/.config/emacs/backups")
  ;; and if it doesn't exist, make it
  (if (not (file-exists-p phd-backup-directory))
      (make-directory phd-backup-directory t))
  ;; configure backup list
  (setq backup-directory-alist `(("." . ,phd-backup-directory)))
  ;; configure backup saving behavior
  (setq make-backup-files t
        backup-by-copying t
        version-control t
        delete-old-versions t
        delete-by-moving-to-trash t
        kept-old-versions 5
        kept-new-versions 10
        auto-save-default t
        auto-save-timeout 15
        auto-save-interval 300)

  ;; configure backup deletion
  (setq delete-by-moving-to-trash t
        trash-directory "~/.local/share/Trash/files")
  ;; trash-directory "~/.Trash")

  ;; save frame position history
  (if (< emacs-major-version 25)
      (progn
        (require 'saveplace)
        (setq-default save-place t))
    (save-place-mode 1))

#+end_src


* GUI

Settings specific to GUI mode.
Does not take effect when executed in a terminal.

#+begin_src emacs-lisp

  (defun new-frame-setup (&optional frame)
    (when (display-graphic-p frame)

      (message "New frame in window system")
      ;; no new frames when opening with Finder/Explorer
      (setq pop-up-frames nil)

      ;; hide bars
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
      (menu-bar-mode -1) ;; if inside window, might be nice to keep

      ;; Scrolling cursor with mouse wheel (instead of frame)
      (global-set-key (kbd "<mouse-4>") 'phd/hydra-prevln)
      (global-set-key (kbd "<mouse-5>") 'phd/hydra-nxtln)
      )
    )

  (add-hook 'after-init-hook 'new-frame-setup)
  (add-hook 'after-make-frame-functions 'new-frame-setup)

#+end_src


* Terminal window

Settings specific to terminal mode.
Does not take effect when executed in a separate window.

#+begin_src emacs-lisp

  (defun new-term-setup (&optional frame)
    (unless (display-graphic-p frame)

      ;; hide bars
      (tool-bar-mode -1)
      (scroll-bar-mode -1)
      (menu-bar-mode -1)

      ;; activate mouse mode
      (xterm-mouse-mode t)
      (mouse-wheel-mode t)

      ;; Scrolling cursor with mouse wheel (instead of frame)
      (global-set-key (kbd "<mouse-4>") 'phd/hydra-prevln)
      (global-set-key (kbd "<mouse-5>") 'phd/hydra-nxtln)
      (define-key key-translation-map [?\C-h] [?\C-?])
      )
    )

  (add-hook 'after-init-hook 'new-term-setup)
  ;; (add-hook 'terminal-init-xterm-hook 'new-term-setup)

#+end_src


* Styling

All style settings are defined here...


** Theme

#+begin_src emacs-lisp
  (use-package phd-ark-theme
    :straight nil
    :init
    (load-theme 'phd-ark :no-confirm)
    :config
    (setq phd-ark-flavor 'iridis)
    (phd-ark-reload))

#+end_src


*** Transparency

#+begin_src emacs-lisp :tangle no

  (set-frame-parameter (selected-frame) 'alpha '(95 . 50))
  (add-to-list 'default-frame-alist '(alpha . (95 . 50)))

#+end_src


*** Gamma adjustment

#+begin_src emacs-lisp :tangle no

  (setq default-frame-alist '((screen-gamma . 1.0)))
  (setq initial-frame-alist '((screen-gamma . 1.0)))

#+end_src


** Font

#+begin_src emacs-lisp

  (set-face-attribute 'default nil :font "JetBrains Mono-14")

  (add-hook 'after-make-frame-functions
            (lambda (&optional frame)
              (when (display-graphic-p frame)
                ;; (set-face-attribute 'default nil :font "Fira Mono-14"))))
                ;; (set-face-attribute 'default nil :font "Roboto Mono-13"))))
                ;; (set-face-attribute 'default nil :font "Monaco-15"))))
                ;; (set-face-attribute 'default nil :font "Hack-13"))))
                (set-face-attribute 'default nil :font "JetBrains Mono-14"))))

#+end_src


*** all-the-icons

All-the-icons is pretty. Install the fonts first from
https://github.com/domtronn/all-the-icons.el/tree/master/fonts

#+begin_src shell :exports none
  cd ~/Downloads
  git clone git@github.com:domtronn/all-the-icons.el.git
#+end_src

... and afterwards load the package:

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src


*** prettify-symbols

#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src


** Tab-line

Customize the ~tab-line~ (activate using ~M-x global-tab-line-mode~)

#+begin_src emacs-lisp
  (use-package tab-line
    :straight nil
    ;; :hook (after-init . global-tab-line-mode)
    :config
    ;; custom configurations
    (defcustom tab-line-tab-min-width 10
      "Minimum width of a tab in characters."
      :type 'integer
      :group 'tab-line)
    (defcustom tab-line-tab-max-width 30
      "Maximum width of a tab in characters."
      :type 'integer
      :group 'tab-line)
    (defun phd/tab-line-tabs-window-buffers ()
      "Return a list of tabs displayed in the tab-line, excluding scrachy ones."
      (let* ((window (selected-window))
             (buffer (window-buffer window))
             (next-buffers (seq-remove (lambda (b) (or (eq b buffer)
                                                       (s-starts-with? "*" (buffer-name b))))
                                       (window-next-buffers window)))
             (next-buffers (seq-filter #'buffer-live-p next-buffers))
             (prev-buffers (seq-remove (lambda (b) (or (eq b buffer)
                                                       (s-starts-with? "*" (buffer-name b))))
                                       (mapcar #'car (window-prev-buffers window))))
             (prev-buffers (seq-filter #'buffer-live-p prev-buffers))
             ;; Remove next-buffers from prev-buffers
             (prev-buffers (seq-difference prev-buffers next-buffers)))
        (append (reverse prev-buffers)
                (list buffer)
                next-buffers)))
    (defun phd/tab-line-name-buffer (buffer &rest _buffers)
      "Create name for tab with padding and truncation.
       If buffer name is shorter than `tab-line-tab-max-width' it gets
       centered with spaces, otherwise it is truncated, to preserve
       equal width for all tabs.  This function also tries to fit as
       many tabs in window as possible, so if there are no room for tabs
       with maximum width, it calculates new width for each tab and
       truncates text if needed.  Minimal width can be set with
       `tab-line-tab-min-width' variable."
      (with-current-buffer buffer
        (let* ((window-width (window-width (get-buffer-window)))
               (tab-amount (length (phd/tab-line-tabs-window-buffers)))
               (window-max-tab-width (if (>= (* (+ tab-line-tab-max-width 3) tab-amount) window-width)
                                         (/ window-width tab-amount)
                                       tab-line-tab-max-width))
               (tab-width (- (cond ((> window-max-tab-width tab-line-tab-max-width)
                                    tab-line-tab-max-width)
                                   ((< window-max-tab-width tab-line-tab-min-width)
                                    tab-line-tab-min-width)
                                   (t window-max-tab-width))
                             3)) ;; compensation for ' x ' button
               (buffer-name (string-trim (buffer-name)))
               (name-width (length buffer-name)))
          (if (>= name-width tab-width)
              (concat  " " (truncate-string-to-width buffer-name (- tab-width 2)) "…")
            (let* ((padding (make-string (+ (/ (- tab-width name-width) 2) 1) ?\s))
                   (buffer-name (concat padding buffer-name)))
              (concat buffer-name (make-string (- tab-width (length buffer-name)) ?\s)))))))

  ;; general setting
  (setq tab-line-close-button-show t
        tab-line-new-button-show nil
        tab-line-separator ""
        tab-line-tab-name-function #'phd/tab-line-name-buffer
        tab-line-tabs-function #'phd/tab-line-tabs-window-buffers
        tab-line-right-button (propertize (if (char-displayable-p ?▶) " ▶ " " > ")
                                          'keymap tab-line-right-map
                                          'mouse-face 'tab-line-highlight
                                          'help-echo "Click to scroll right")
        tab-line-left-button (propertize (if (char-displayable-p ?◀) " ◀ " " < ")
                                         'keymap tab-line-left-map
                                         'mouse-face 'tab-line-highlight
                                         'help-echo "Click to scroll left")
        tab-line-close-button (propertize (if (char-displayable-p ?×) " × " " x ")
                                          'keymap tab-line-tab-close-map
                                          'mouse-face 'tab-line-close-highlight
                                          'help-echo "Click to close tab"))

  ;; mode in which tab-line is not displayed
  (dolist (mode '(term-mode
                  vterm-mode))
    (add-to-list 'tab-line-exclude-modes mode))
  )
#+end_src


** Dashboard


My Custom dashboard functions

#+begin_src emacs-lisp

  (defun phd-db/visit-dreamworld (&rest _)
    "Go to my https://github.com/phdenzel website."
    (interactive)
    (browse-url "https://github.com/phdenzel"))

  (defun phd-db/show-stars (&rest _)
    "Show stars"
    (interactive)
    (message "stars"))

  (defun phd-db/show-flags (&rest _)
    "Show flags"
    (interactive)
    (message "flags"))

#+end_src


Create custom mode section

#+begin_src emacs-lisp

  (setq phd-db-modes (list 'mu4e))

  (defun phd-db/insert-modes (list-size)
    (dashboard-insert-section
     "Modes:"
     phd-db-modes
     list-size
     'modes
     "x"
     `(lambda (&rest ignore) (message "%s" (quote ,el)))
     (format "%s" el)
     ))

#+end_src


My dashboard configuration

#+begin_src emacs-lisp

  (use-package dashboard
    :straight nil
    :load-path "~/local/phd-dashboard/"
    :config
    (dashboard-setup-startup-hook)
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    ;; Banner & Appearance
    (setq dashboard-center-content t
          dashboard-startup-banner 'phdemacs
          dashboard-set-heading-icons t
          dashboard-set-file-icons t
          dashboard-set-init-info nil)
    (setq dashboard-items '((modes     . 5) (bookmarks . 5)
                            (projects  . 5) (recents   . 3)))
    ;; Functionality
    (setq dashboard-modes-alist
          '(("mu4e" . mu4e)
            ("phd-modeline-mode" . phd-modeline-mode)
            ("tab-line" . global-tab-line-mode)))
    (setq dashboard-mode-status-alist
          '(("mu4e" . mu4e~proc-running-p)
            ("phd-modeline-mode" . phd-modeline-mode)
            ("tab-line" . global-tab-line-mode)))
    (setq dashboard-projects-switch-function
          'counsel-projectile-switch-project-by-name)
    ;; Navigator
    (setq dashboard-set-navigator t
          dashboard-navigator-buttons
          `(((,(all-the-icons-octicon "mark-github"
                                      :height 1.1
                                      :v-adjust 0.0) nil "Browse homepage"
                phd-db/visit-dreamworld link))
            ;; ---
            (("★" nil "Show stars" phd-db/show-stars font-lock-keyword-face)
             ;; ("?" "" "Help" (lambda (&rest _) (message "help")) default)
             ("⚑" nil "Show flags" phd-db/show-flags font-lock-string-face))
            ))
    ;; Footer
    (setq dashboard-footer-messages '("Deus Ex Machina!")
          dashboard-footer-icon
          (all-the-icons-octicon "dashboard"
                                 :height 1.1
                                 :v-adjust -0.05
                                 :face 'font-lock-keyword-face))
    )

#+end_src


** Modeline

For a long time, I used the ~powerline~ emacs package to customize my
modeline. However, it turns out that the powerline and my
customizations caused emacs to slow down noticeably (at least, I think
so... after switching to my own implementation, I noticed a speed up).

So, I decided to use Emacs' built-in ~mode-line~ and apply a light
customization myself. That's all I need anyways...

#+begin_src emacs-lisp

  (use-package phd-modeline
    :straight nil
    :load-path "~/local/phd-modeline"
    :after all-the-icons
    :hook (after-init . phd-modeline-mode)
    :bind (("C-x |" . phd-modeline-mode))
    :init
    (require 'phd-mu4e-setup)
    :config
    (setq phd-modeline-mu4e-unread-query 'phd-mu4e-inbox-query)
    (phd-modeline-column-mode t)
    (phd-modeline-mail-mode t)
    (setq phd-modeline-format
          (list
           '(:eval (phd-modeline-bar))
           '(:eval (phd-modeline-whitespace))
           '(:eval (phd-modeline-buffer-lock-icon))
           '(:eval (phd-modeline-buffer-name))
           '(:eval (phd-modeline-buffer-modified-icon))
           '(:eval (phd-modeline-whitespace))
           '(:eval (phd-modeline-buffer-position))
           '(:eval (phd-modeline-media-info))
           '(:eval (phd-modeline-whitespace))
           '(:eval (phd-modeline-flycheck-status))
           '(:eval (phd-modeline-whitespace 4))
           '(:eval (phd-modeline-vc-icon 1 1 1))
           '(:eval (phd-modeline-vc-status))
           '(:eval (phd-modeline-whitespace 4))
           '(:eval (phd-modeline-mail-icon))
           '(:eval (phd-modeline-mail-status))
           '(:eval (phd-modeline-whitespace))
           '(:eval (phd-modeline-space-between 4))
           '(:eval (phd-modeline-mode-icon))
           '(:eval (phd-modeline-whitespace))
           '(:eval (phd-modeline-major-mode))
           '(:eval (phd-modeline-whitespace))))
    )

#+end_src

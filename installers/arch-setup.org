#+AUTHOR: Philipp Denzel
#+TITLE: Arch setup
#+OPTIONS: num:nil
#+OPTIONS: toc:4

Once you have a clean install of Arch Linux and verified that your
network service is up and running, we can go ahead with the setup and
customize Arch to our liking.

The following explains what I usually install and in what order.  You
can also simply install all packages beforehand, and skip the
individual package installs below, which could speed up the setup
process a bit. For this, simply run the ~arch.sh~ install script
(after the AUR helper install).


* Table of Contents :TOC@4:
- [[#setup][Setup]]
  - [[#drivers][Drivers]]
  - [[#ssh-keys][SSH keys]]
  - [[#install-aur-helper][Install AUR helper]]
  - [[#dotfiles][Dotfiles]]
      - [[#optional-neofetch][Optional: ~neofetch~]]
      - [[#optional-gui-for-theming][Optional: GUI for theming]]
  - [[#xmonad--xmobar][XMonad & xmobar]]
  - [[#dmenu][dmenu]]
  - [[#more-suckless-tools][More suckless tools]]
    - [[#optional-xmobar_wttr---an-xmobar-addon][Optional: xmobar_wttr - an xmobar addon]]
    - [[#optional-licht---hue-lights-controller-applet][Optional: licht - Hue lights controller applet]]
    - [[#optional-display-manager][Optional: display manager]]
  - [[#basic-programs][Basic programs]]
    - [[#file-managers][File managers]]
    - [[#system-tools][System tools]]
    - [[#disk-utilities][Disk utilities]]
    - [[#android-utilities][Android utilities]]
    - [[#backup-utilities][Backup utilities]]
    - [[#cloud-folders][Cloud folders]]
    - [[#dev-tools][Dev tools]]
    - [[#web-packages][Web packages]]
    - [[#networking-tools][Networking tools]]
    - [[#lamplemp-stack][LAMP/LEMP stack]]
      - [[#optional-dnsmasq-dns-setup][Optional: dnsmasq DNS setup]]
      - [[#optional-nginx-setup][Optional: NGINX setup]]
      - [[#optional-nfs][Optional: NFS]]
    - [[#jellyfin][Jellyfin]]
    - [[#nextcloud][Nextcloud]]
    - [[#mail-server][Mail server]]
    - [[#mail-mu4e-and-mbsync][Mail (mu4e and mbsync)]]
    - [[#password-utilities][Password utilities]]
    - [[#utilities][Utilities]]
    - [[#media-programs][Media programs]]
    - [[#graphics][Graphics]]
    - [[#fonts][Fonts]]
      - [[#optional-grub-fonts][Optional: GRUB fonts]]
    - [[#device-software][Device software]]
    - [[#virtualization][Virtualization]]
- [[#maintenance][Maintenance]]

* Setup

  My setup routine is relatively simple.  First, refresh the
  repositories
  #+begin_src shell
    sudo pacman -Syyu
  #+end_src

  I like to uncomment the ~Color~ setting in ~/etc/pacman.conf~ for a
  more clearly presented output
  #+begin_src shell
    sudo sed -i 's/#Color/Color/g' /etc/pacman.conf
  #+end_src


** Drivers
  
  Next, install all necessary xorg-drivers (check them with ~sudo
  pacman -Ss xf86-video~; if in doubt simply install a bunch, the
  system will choose the right one automatically). My setup consists
  of an Intel processor and an Nvidia GPU (proprietary drivers are a
  thorn in my eye, but for now I'm stuck with what works)
  #+begin_src shell
    sudo pacman -S xf86-video-intel nvidia nvidia-utils nvidia-settings fbset
  #+end_src
  if you have an AMD card simply swap out the packages above with
  ~xf86-video-amdgpu~.

  Make sure to regenerate the initcpio if an nvidia-driver update is
  installed. If you don't want to manually regenerate it, add a pacman
  hook ~/etc/pacman.d/hooks/nvidia.hook~ to ensure triggering
  initramfs update
  #+begin_src conf
    [Trigger]
    Operation=Install
    Operation=Upgrade
    Operation=Remove
    Type=Package
    Target=nvidia
    Target=linux

    [Action]
    Description=Update Nvidia module in initcpio
    Depends=mkinitcpio
    When=PostTransaction
    NeedsTargets
    Exec=/bin/sh -c 'while read -r trg; do case $trg in linux) exit 0; esac; done; /usr/bin/mkinitcpio -P'
  #+end_src

  Nvidia drivers unfortunately don't play well with the kernel
  framebuffer, which makes setting resolutions of the tty a
  nightmare. For me, the solution was to disable CSM in the UEFI BIOS,
  and changing the ~/etc/defaults/grub~ to to choose the proper
  resolution. The relevant lines are

  #+begin_src conf
    GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet nvidia-drm.modeset=1"
    GRUB_GFXMODE=2560x1440x32,1920x1080x32,auto
    GRUB_GFXPAYLOAD_LINUX=keep
  #+end_src

  Once you're done modifying your GRUB settings, regenerate the
  GRUB configuration
  #+begin_src shell
    grub-mkconfig -o /efi/grub/grub.cfg
  #+end_src

  
** SSH keys

   Generate an SSH key
   #+begin_src shell
     sudo pacman -S openssh
     ssh-keygen -t ed25519 -C "phdenzel@gmail.com"
   #+end_src
   and copy the public key to all trusted hosts, e.g.

#+begin_src shell
  ssh-copy-id user@hostname
#+end_src


** Install AUR helper

   Clone the ~yay~ AUR helper repository and install it (I like to
   store sources which get locally installed to a folder in my home
   directory ~~/local~)

   #+begin_src shell
     mkdir ~/local
     cd ~/local
     git clone https://aur.archlinux.org/yay.git
     cd yay
     makepkg -si PKGBUILD
     cd
   #+end_src


** Dotfiles

   Since you're reading this, you know that I have my dotfiles stored
   in a GitHub repository. It'll install configurations of my window
   manager ~XMonad~, ~emacs~, some bash scripts, and GTK/QT themes.

   Prerequisites have to be installed fist
   #+begin_src shell
     sudo pacman -S rsync ghc ghc-static qt5ct
   #+end_src

   Install everything from the dotfiles repository (no need to source
   the config files in the end)
   #+begin_src shell
     git clone git@github.com:phdenzel/dotfiles.git
     cd ~/dotfiles

     ./bootstrap.sh --bin

     ./bootstrap.sh --emacs

     # This command might take a minute
     ./bootstrap.sh --themes
     gsettings set org.gnome.desktop.interface gtk-theme phd-dark

     ./bootstrap.sh
   #+end_src

   Some applications (such as ~timeshift-gtk~) need ~sudo~ priviliges,
   and thus can't use locally installed themes. Therefore, we need to
   copy them to the respective directories in ~/usr/share/~
   #+begin_src shell
     sudo ln -s $HOME/.themes/phd-dark /usr/share/themes/phd-dark
     sudo ln -s $HOME/.config/gtk-3.0/settings.ini /etc/gtk-3.0/settings.ini
     sudo ln -s $HOME/.config/gtk-2.0/gtkrc-2.0 /etc/gtk-2.0/gtkrc
   #+end_src

   At last edit the file in ~.config/USERINFO~ with the attributes
   corresponding to your username and machine, and copy it to your
   ~.config~ directory
   #+begin_src shell
     cp .config/USERINFO $HOME/.config/
   #+end_src

**** Optional: ~neofetch~

     While everything works without it, I like the look and
     convenience of the ~neofetch~ script
     
     #+begin_src shell
       cd ~/local
       git clone git@github.com:phdenzel/neofetch.git
       cd neofetch
       make install
       cd
     #+end_src

**** Optional: GUI for theming

     If you prefer GUIs to set up your themes, you might want to install
     #+begin_src shell
       sudo pacman -S lxappearance
     #+end_src


** XMonad & xmobar

   To get the latest version of XMonad and xmobar, I like to compile
   them from source myself. This takes a bit longer than simply
   installing it with the package manager.  First, install all
   required packages

   #+begin_src shell
     sudo pacman -S stack xorg-server xorg-apps xorg-xinit xorg-xmessage xorg-xrandr libx11 libxft libxinerama libxrandr libxss pkgconf wireless_tools
   #+end_src

   ~stack~ provides an easy way to compile and install XMonad and
   xmobar from a sandboxed environment

   #+begin_src shell
     mkdir -p ~/local/xmonad
     cd ~/local/xmonad
     stack setup
     stack upgrade
     git clone git@github.com:xmonad/xmonad.git
     git clone git@github.com:xmonad/xmonad-contrib.git
     git clone git@github.com:jaor/xmobar.git
     stack init
     cp ~/dotfiles/.config/xmonad/stack.yml stack.yml
     stack install
     sudo ln -s ~/.local/bin/xmonad /usr/bin
     sudo mkdir -p /usr/share/xsessions
     sudo ln -s ~/.config/xmonad/xmonad.desktop /usr/share/xsessions
     cd
   #+end_src


** dmenu

   ~dmenu~ accompanies XMonad perfectly. Once again, as this is a
   suckless tool to which one might want to apply some patches,
   I prefer compiling my own version

   #+begin_src shell
     cd ~/local
     git clone git@github.com:phdenzel/dmenu.git
     cd dmenu
     make patching
     make
     sudo make install
     cd
   #+end_src


** More suckless tools

   To complete the tiling window manager setup, we furthermore install
   a compositor, sys-tray, and image viewer (for setting wallpapers)

   #+begin_src shell
     sudo pacman -S picom feh trayer
   #+end_src


*** Optional: xmobar_wttr - an xmobar addon

    I wrote my own weather fetcher as python program which nicely
    formats and iconifies the information for ~xmobar~. Python should
    already be installed on a clean arch installation, but as ~pip~
    (and ~pipenv~) are not, we first have to install these packages
    (as well as ~emacs~ for compiling the README)

    #+begin_src shell
      sudo pacman -S emacs python-pip python-pipenv
    #+end_src

    ~xmobar_wttr~ can be installed via ~pip~, but I usually just clone
    the repo and install it from source

    #+begin_src shell
      cd ~/local
      git clone git@github.com:phdenzel/xmobar_wttr.git
      cd xmobar_wttr
      make pkg
      python3 setup.py install --user
      cd
    #+end_src


*** Optional: licht - Hue lights controller applet

    I used to use a systray GNOME applet back on Pop!_OS which was
    able to connect to a Philips Hue bridge in my network, but
    unfortunately this doesn't work on Arch linux, so I wrote a
    replacement for it:

    #+begin_src shell
      cd ~/local
      git clone git@github.com:phdenzel/licht.git
      cd licht
      make pkg
      python3 setup.py install --user
    #+end_src

    If this should not work, consider simply installing it via ~pip~.
    I try to keep the releases up-to-date:

    #+begin_src shell
      pip install licht
    #+end_src


*** Optional: display manager

    I personally don't use a display manager, as I encrypt my drives
    and use xinit on login. If I would use a login manager though, it
    probably would be ~lightdm~ or ~ly~. So,

    #+begin_src shell
      yay -S ly
      sudo systemctl enable ly.service
    #+end_src

    or

    #+begin_src shell
      sudo pacman -S lightdm lightdm-webkit2-greeter
      sudo systemctl enable lightdm
    #+end_src

    If you decided on ~lightdm~, enable its ~lightdm-webkit2-greeter~
    in ~/etc/lightdm/lightdm.conf~, otherwise it won't work.


** Basic programs

   Install my favorite terminal, browser and mail client
   #+begin_src shell
     yay -S alacritty-git brave-bin mailspring
   #+end_src

   Alacritty uses GPU hardware acceleration, but if no hardware
   acceleration is available (on very old hardware for instance), run
   ~alacritty~ with ~LIBGL_ALWAYS_SOFTWARE=1 /usr/bin/alacritty~ and
   replace ~Exec=env LIBGL_ALWAYS_SOFTWARE=1 /usr/bin/alacritty~ in
   ~/usr/share/applications/Alacritty.desktop~

   Mailspring needs the ~gnome-keyring~ package for some reason, so to
   get it working, we will have to install it
   #+begin_src shell
     sudo pacman -S gnome-keyring
   #+end_src

   In the subsections are categorized, and are here for completion. I
   usually install these via my install script ~arch.sh~

*** File managers
    GUI and terminal-based file managers
    #+begin_src shell
      sudo pacman -S pcmanfm gvfs udisks2 xarchiver ranger highlight
    #+end_src

*** System tools

    Systemd components
    #+begin_src shell
      sudo pacman -S systemd-resolvconf
    #+end_src

    Z-shell, fuzzy-finder
    #+begin_src shell
      sudo pacman -S zsh fzf
    #+end_src

    RUST-powered command-line program variants

    #+begin_src shell
      sudo pacman -S bat exa zoxide fd ripgrep dust
    #+end_src

    
    Bash tab completion, spell checkers, and locate utils
    #+begin_src shell
      sudo pacman -S bash-completion man-db mlocate hunspell hunspell-en_us
    #+end_src

    Xorg utilities
    #+begin_src shell
      sudo pacman -S xdotool xscreensaver
    #+end_src

    System tray applets
    #+begin_src shell
      sudo pacman -S network-manager-applet blueman volumeicon
    #+end_src

    For keeping the clock running (NTP client)
    #+begin_src shell
      sudo pacman -S chrony
      sudo systemctl enable --now chronyd.service
    #+end_src

*** Disk utilities
    File system tabulator, disk formatter/analyser, and various compression, copy, and job control programs
    #+begin_src shell
      sudo pacman -S arch-install-scripts gptfdisk zip unzip rsync cronie htop
    #+end_src

*** Android utilities
    To connect with an Android system, we need the MTP protocol
    #+begin_src shell
      sudo pacman -S mtpfs gvfs-mtp gvfs-gphoto2
    #+end_src

    For Android 4+ devices, additionally install
    #+begin_src shell
      yay -S jmtpfs
    #+end_src

*** Backup utilities
    Timeshift seems to integrate well with btrfs, however after using
    it for a while, I found it simply a bit too buggy for a backup
    program. I also dislike snapper, because of how it stores its
    snapshots all over the place (in @{subvols}/.snapshots).

    So, these days I'm backing up my subvolumes with my own automated
    scripts. For more infos have a look at my [[https://github.com/phdenzel/btrsnap][btrsnap]] repository.

*** Cloud folders

    Dropbox has very little space for free, but it's still good.
    #+begin_src shell
      yay -S dropbox
    #+end_src

    Once you're in your graphical environment, set up dropbox using
    #+begin_src shell
      dropbox start -i
    #+end_src

    For a better self-hosted solution, set up a LAMP or LEMP stack and
    install ~nextcloud~ (see below).

*** Dev tools
    Languages: lisp, haskell, rust, ruby, LaTeX
    #+begin_src shell
      sudo pacman -S emacs vim cmake pyenv ghc ghc-static rust ruby rubygems texlive-most texlive-lang
    #+end_src

    Installing jekyll (my preferred dev tool for static websites and blogs)
    #+begin_src shell
      gem install bundler webrick jekyll
    #+end_src
    And remember to source your .zshenv afterwards to add ruby binaries to your PATH.

*** Web packages
    Version control, data transfer, text-based browser programs
    #+begin_src shell
      sudo pacman -S git wget curl transmission-cli transmission-gtk lynx w3m
    #+end_src

*** Networking tools
    VPN, tools for network control, discovery and security auditing
    #+begin_src shell
      sudo pacman -S ethtool wol nfs-utils firewalld fail2ban nginx dnsmasq wireguard-tools nmap
    #+end_src

    Enable all services
    #+begin_src shell
      sudo systemctl enable --now fail2ban
      sudo systemctl enable --now firewalld.service
      sudo firewall-cmd --set-default-zone=home
    #+end_src

*** LAMP/LEMP stack

    A LAMP or LEMP stack

    For L*A*MP: install Apache
    #+begin_src shell
      sudo pacman -S apache php-apache
    #+end_src

    For L*E*MP: install nginx
    #+begin_src shell
      sudo pacman -S nginx
    #+end_src
    I usually prefer nginx over apache. So, the following sections
    will assume the LEMP stack was installed.

    MariaDB install
    #+begin_src shell
      sudo pacman -S mariadb mariadb-clients mariadb-libs
    #+end_src

    MariaDB configuration
    #+begin_src shell
      sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql
      sudo systemctl enable mariadb
      sudo systemctl start mariadb
      sudo mysql_secure_installation
    #+end_src
    Go through the questions from the last command and choose what is
    fitting for you. In my case, I went with the defaults, except that
    I did not change the root password.

    Create a database with
    #+begin_src shell
      sudo mysql -u root -p
    #+end_src
    This obvious only has to be done only if a database is needed for
    another application. For instance, ~nextcloud~ requires a database
    which I called ~nextcloud~
    #+begin_src shell
      MariaDB [(none)]> CREATE DATABASE nextcloud;
      MariaDB [(none)]> CREATE USER 'nextcloud'@'localhost' IDENTIFIED BY 'xxxxxxxx';
      MariaDB [(none)]> GRANT ALL PRIVILEGES on nextcloud.* to 'nextcloud'@'localhost';
      MariaDB [(none)]> FLUSH privileges;
      MariaDB [(none)]> quit;
    #+end_src

    Install PHP
    #+begin_src shell
      sudo pacman -S php php-gd php-cgi php-fpm php-intl php-imagick
    #+end_src

    For application-specific PHP configurations, I usually use
    dedicated copies of ~/etc/php/php.ini~ in the according
    applications configuration directory.
    
**** Optional: dnsmasq DNS setup

     I like to set up a local DNS server to easily access all my home
     services through local names instead of IP addresses. Therefore,
     I use ~dnsmasq~'s DNS features and use ~nginx~ as a reverse
     proxy.

     First stop any (potentially) running ~systemd-resolved~ services
     #+begin_src shell
       sudo systemctl stop systemd-resolved
       sudo systemctl disable systemd-resolved
     #+end_src

     You find the default ~dnsmasq~ configuration in ~/etc/dnsmasq.conf~.
     #+begin_src shell
       echo "conf-dir=/etc/dnsmasq.d,.bak" | sudo tee -a /etc/dnsmasq.conf
       sudo mkdir -p /etc/dnsmasq.d
       sudo touch /etc/dnsmasq.d/home.conf
     #+end_src
     
     All customizations should be added to the ~/etc/dnsmasq.d~
     directory.  Add a custom configuration file
     e.g. ~/etc/dnsmasq.d/home.conf~
     #+begin_src conf
       # turn off dhcp on enp3s0
       no-dhcp-interface=enp3s0
       # never forward plain names
       domain-needed
       # neve forward addresses in the non-routable address space
       bogus-priv
       # add domain to hostnames
       expand-hosts
       # domain to be added if expand-hosts is set
       domain=home
       # local domain to be served from /etc/hosts file
       local=/home/
       # don't read /etc/resolv.conf
       no-resolv
       # external nameservers Cloudflare/Google
       server=1.1.1.1
       server=8.8.8.8
     #+end_src

     Afterwards, add the names of the virtual hosts to ~/etc/hosts~, e.g.
     #+begin_src conf
       # Static table lookup for hostnames.
       # See hosts(5) for details.
       127.0.0.1	localhost
       ::1		    localhost
       #127.0.1.1	archphoenix.localdomain	archphoenix

       # fritzbox
       192.168.178.1 fritz.box
       # main hostname
       192.168.178.42 my
       # jellyfin
       192.168.178.42 jellyfin
       # etc...
     #+end_src

     If you're running ~firewalld~, open the DNS ports 53/UDP and
     53/TCP.
     #+begin_src shell
       sudo firewall-cmd --add-service dns
       sudo firewall-cmd --add-service dns --permanent
     #+end_src

     Once everything is configured start the service with
     #+begin_src shell
       sudo systemctl start dnsmasq.service
       sudo systemctl enable dnsmasq.service
     #+end_src

**** Optional: NGINX setup

     I prefer a lightweight ~nginx~ configuration over an (in my
     opinion) intrinsically heavier ~apache~ setup.
     #+begin_src shell
       sudo pacman -S nginx certbot certbot-nginx
     #+end_src

     It seems when ~nginx~ is installed on Arch Linux, all default
     configurations are found in a single file
     ~/etc/nginx/nginx.conf~. However, I like to keep the global
     configurations there, but move the server blocks to
     ~/etc/nginx/conf.d/default.conf~.

     On Arch Linux, the ~conf.d~ directory has to be created
     #+begin_src shell
       sudo mkdir -p /etc/nginx/conf.d
     #+end_src
     
     My ~/etc/nginx/nginx.conf~ looks like
     #+begin_src conf
       user http;
       worker_processes  4;
       error_log  /var/log/nginx/error.log  warn;

       events {
           worker_connections  1024;
       }

       http {
           include       mime.types;
           default_type  application/octet-stream;

           log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                             '$status $body_bytes_sent "$http_referer" '
                             '"$http_user_agent" "$http_x_forwarded_for"';
           access_log  /var/log/nginx/access.log  main;

           sendfile        on;

           keepalive_timeout  65;

           types_hash_max_size	4096;

           include /etc/nginx/conf.d/*.conf;

       }
     #+end_src

     And the default configuration could be something like
     ~/etc/nginx/conf.d/default.conf~
     #+begin_src conf
       server {
           listen       80;
           listen	 [::]:80;
           server_name  my.home;

           #charset koi8-r;
           #access_log  logs/host.access.log  main;

           location / {
               root   /usr/share/nginx/html;
               index  index.html index.htm;
           }

           #error_page  404              /404.html;

           # redirect server error pages to the static page /50x.html
           #
           error_page   500 502 503 504  /50x.html;
           location = /50x.html {
               root   /usr/share/nginx/html;
           }

           # proxy the PHP scripts to Apache listening on 127.0.0.1:80
           #
           #location ~ \.php$ {
           #    proxy_pass   http://127.0.0.1;
           #}

           # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
           #
           #location ~ \.php$ {
           #    root           html;
           #    fastcgi_pass   127.0.0.1:9000;
           #    fastcgi_index  index.php;
           #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
           #    include        fastcgi_params;
           #}

           # deny access to .htaccess files, if Apache's document root
           # concurs with nginx's one
           #
           #location ~ /\.ht {
           #    deny  all;
           #}
       }


       # another virtual host using mix of IP-, name-, and port-based configuration
       #server {
       #    listen       8000;
       #    listen       somename:8080;
       #    server_name  somename  alias  another.alias;

       #    location / {
       #        root   html;
       #        index  index.html index.htm;
       #    }
       #}


       # HTTPS server
       #server {
       #    listen       443 ssl;
       #    server_name  localhost;

       #    ssl_certificate      cert.pem;
       #    ssl_certificate_key  cert.key;

       #    ssl_session_cache    shared:SSL:1m;
       #    ssl_session_timeout  5m;

       #    ssl_ciphers  HIGH:!aNULL:!MD5;
       #    ssl_prefer_server_ciphers  on;

       #    location / {
       #        root   html;
       #        index  index.html index.htm;
       #    }
       #}
     #+end_src
     Most of these server blocks are unchanged from the initially
     installed file, commented out, and simply act as suggestions and
     tutorials on how to setup ~nginx~.

**** Optional: NFS

     NFS allows you to expose folders to other machines on the network.
     For this we only need ~nfs-utils~. Add the folders you want to
     expose to ~/etc/exports~, e.g.

     #+begin_src conf
       /data/backups   *(rw,sync)
     #+end_src
     For more infos on exporting see [[https://man.archlinux.org/man/exports.5][man/exports.5]].

     After editing the ~/etc/exports~ file, you need to run ~sudo
     exportfs -arv~ to update the nfs entries. The service is enabled
     with
     #+begin_src shell
       sudo systemctl enable --now nfs-server
     #+end_src

     If you're running a firewall, you have to open TCP and UDP ports
     111, 2049, and 20048. In firewalld you can accomplish this by
     adding services for nfs, mountd and rpc-bind
     #+begin_src shell
       sudo firewall-cmd --add-service nfs
       sudo firewall-cmd --add-service nfs --permanent
       sudo firewall-cmd --add-service mountd
       sudo firewall-cmd --add-service mountd --permanent
       sudo firewall-cmd --add-service rpc-bind
       sudo firewall-cmd --add-service rpc-bind --permanent
     #+end_src

     On the client-side you can then discover the shared folders using
     #+begin_src shell
       showmount -e <hostname|server-ip>
     #+end_src

     and mount them with

     #+begin_src shell
       sudo mkdir -p /nfs/backups
       sudo mount -t nfs 192.168.xx.xx:/data/backups /nfs/backups
     #+end_src

     To permanently mount the nfs shares, add them to your /etc/fstab file
     #+begin_src conf
       hostname:/data/backups  /nfs/backups  nfs4  rw,sync,_netdev,addr=192.168.xx.xx  0 0
     #+end_src

     If you have any issues, check if you assigned the correct
     ownership/permissions to the nfs folders.

*** Jellyfin

    Although ~jellyfin~ can be installed via the AUR for any Arch
    Linux distro, most builds will probably fail due to build issues
    related to ~Node.js~. So far, I had best success installing the
    ~jellyfin-git~ versions

    #+begin_src shell
      yay -S jellyfin-git
    #+end_src

    If you managed to build ~jellyfin~, you can proceed and enable the service
    #+begin_src shell
      sudo systemctl enable jellyfin.service
      sudo systemctl start jellyfin.service
    #+end_src
    
    Make sure that if a firewall is up, ~jellyfin~ can communicate via
    an open port. For the default port use
    #+begin_src shell
      sudo firewall-cmd --add-service jellyfin
      sudo firewall-cmd --add-service jellyfin --permanent
    #+end_src

    This should be enough to get up and running... for the initial
    setup go to ~127.0.0.1:8096~ in your browser of choice.

    You can also set up a reverse proxy pass in nginx. For this,
    create the file ~/etc/nginx/conf.d/jellyfin.conf~ with the
    following content
    #+begin_src conf
server {
    listen       80;
    listen	 [::]:80;
    #server_name  jellyfin.home;

    # Uncomment to redirect to https
    # return 301 https://$host$request_uri;

#}
#server {
    #listen 443 ssl https2;
    #listen [::]:443 ssl http2;
    server_name  jellyfin.home;

    #access_log  logs/host.access.log  main;
    client_max_body_size 32M;

    # use a variable to store the upstream proxy
    set $jellyfin jellyfin;
    resolver 127.0.0.1 valid=30;

    #ssl_certificate /etc/letsencrypt/live/DOMAIN_NAME/fullchain.pem;
    #ssl_certificate_key /etc/letsencrypt/live/DOMAIN_NAME/privkey.pem;
    #include /etc/letsencrypt/options-ssl-nginx.conf;
    #ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    #add_header Strict-Transport-Security "max-age=31536000" always;
    #ssl_trusted_certificate /etc/letsencrypt/live/DOMAIN_NAME/chain.pem;
    #ssl_stapling on;
    #ssl_stapling_verify on;

    # Security / XSS Mitigation Headers
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";

    # Content Security Policy
    # Enforces https content and restricts JS/CSS to origin
    # External Javascript (such as cast_sender.js for Chromecast) must be whitelisted.
    #add_header Content-Security-Policy "default-src https: data: blob: http://image.tmdb.org; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' https://www.gstatic.com/cv/js/sender/v1/cast_sender.js https://www.gstatic.com/eureka/clank/95/cast_sender.js https://www.gstatic.com/eureka/clank/96/cast_sender.js https://www.gstatic.com/eureka/clank/97/cast_sender.js https://www.youtube.com blob:; worker-src 'self' blob:; connect-src 'self'; object-src 'none'; frame-ancestors 'self'";

    location = / {
    	return 302 http://$host/web/;
    	#return 302 https://$host/web/;
    }

    location / {
        # Proxy main Jellyfin traffic
        proxy_pass http://$jellyfin:8096;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Protocol $scheme;
        proxy_set_header X-Forwarded-Host $http_host;

        # Disable buffering when the nginx proxy gets very resource heavy upon streaming
        proxy_buffering off;
    }

    # location block for /web - This is purely for aesthetics so /web/#!/ works instead of having to go to /web/index.html/#!/
    location = /web/ {
        # Proxy main Jellyfin traffic
        proxy_pass http://$jellyfin:8096/web/index.html;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Protocol $scheme;
        proxy_set_header X-Forwarded-Host $http_host;
    }

    location /socket {
        # Proxy Jellyfin Websockets traffic
        proxy_pass http://$jellyfin:8096;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Protocol $scheme;
        proxy_set_header X-Forwarded-Host $http_host;
    }

}
    #+end_src

    Uncomment the relevant lines once you set up HTTPS.

*** Nextcloud

    Before installing and configuring ~nextcloud~, install the LEMP
    stack.

    If you haven't done so, start MariaDB and create a database and a
    user with all priviliges (as shown in the example of the LAMP/LEMP
    section). Also, don't forget to start and enable the ~mariadb.service~
    #+begin_src shell
      sudo systemctl start mariadb
      sudo systemctl enable mariadb
    #+end_src

    Once the LEMP stack has been installed and set up, we create a
    configuration file for nginx ~/etc/nginx/conf.d/nextcloud.conf~
    #+begin_src conf
      # Custom configuration based on official nginx configuration
      # https://docs.nextcloud.com/server/stable/admin_manual/installation/nginx.html#nextcloud-in-the-webroot-of-nginx
      server {
          listen       80;
          listen	 [::]:80;
          server_name  nextcloud.home;

          #charset koi8-r;
          #access_log  logs/host.access.log  main;

          # set upload size and timeout
          client_max_body_size 512M;
          client_body_timeout 300s;
          fastcgi_buffers 64 4K;

          # enable gzip
          gzip on;
          gzip_vary on;
          gzip_comp_level 4;
          gzip_min_length 256;
          gzip_proxied expired no-cache no-store private no_last_modified no_etag auth;
          gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/wasm application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy;

          # Security / XSS Mitigation Headers
          add_header Referrer-Policy "no-referrer" always;
          add_header X-Frame-Options "SAMEORIGIN" always;
          add_header X-XSS-Protection "1; mode=block" always;
          add_header X-Content-Type-Options "nosniff" always;
          add_header X-Robots-Tag "none" always;
          add_header X-Download-Options "noopen" always;
          add_header X-Permitted-Cross-Domain-Policies "none" always;
          # hide information leak
          fastcgi_hide_header X-Powered-By;

          # path to the nextcloud installation
          root /usr/share/webapps/nextcloud/;
          # fallback handling directories
          index index.php index.html /index.php$request_uri;

          # handle Microsoft DAV clients
          location = / {
              if ( $http_user_agent ~ ^DavClnt ) {
                  return 302 /remote.php/webdav/$is_args$args;
              }
            }

          # enable automated access
          location = /robots.txt {
              allow all;
              log_not_found off;
              access_log off;
          }

          # well-known URIs
          location ^~ /.well-known {

              location = /.well-known/carddav {
                  return 301 $scheme://$host/remote.php/dav/; }
              location = /.well-known/caldav {
                  return 301 $scheme://$host/remote.php/dav/; }

              location /.well-known/acme-challenge {
                  try_files $uri $uri/ =404; }
              location /.well-known/pki-validation {
                  try_files $uri $uri/ =404; }

              # Let Nextcloud's API for `/.well-known` URIs handle all other
              # requests by passing them to the front-end controller.
              return 301 /index.php$request_uri;
          }

          # hide certain paths from clients
          location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)(?:$|/) {
              deny all; }
          location ~ ^/(?:\.|autotest|occ|issue|indie|db_|console) {
              deny all; }


          # PHP block (should come before all blocks handling static assets)
          location ~ \.php(?:$|/) {
              # legacy support
              rewrite ^/(?!index|remote|public|cron|core\/ajax\/update|status|ocs\/v[12]|updater\/.+|oc[ms]-provider\/.+|.+\/richdocumentscode\/proxy) /index.php$request_uri;

              fastcgi_split_path_info ^(.+?\.php)(/.*)$;
              set $path_info $fastcgi_path_info;	

              include fastcgi_params;
              try_files $fastcgi_script_name =404;

              fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
              fastcgi_param PATH_INFO $path_info;
              #fastcgi_param HTTPS on;

              # avoid sending the security headers twice
              fastcgi_param modHeadersAvailable true;
              fastcgi_param front_controller_active true;

              fastcgi_pass unix:/run/php-fpm/nextcloud.sock;

              fastcgi_intercept_errors on;
              fastcgi_request_buffering off;

              fastcgi_max_temp_file_size 0;
          }

          #
          location ~ \.(?:css|js|svg|gif|png|jpg|ico|wasm|tflite|map)$ {
              try_files $uri /index.php$request_uri;
              expires 6M;
              #add_header Cache-Control "public, max-age=15778463, $asset_immutable";
              # don't log access to assets
              access_log off;

              location ~ \.wasm$ {
                  default_type application/wasm;
              }
          }

          location ~ \.woff2?$ {
              try_files $uri /index.php$request_uri;
              # cache-control policy
              expires 7d;
              # don't log access to assets
              access_log off;
          }

          location /remote {
              return 301 /remote.php$request_uri;
          }

          location / {
              try_files $uri $uri/ /index.php$request_uri;
          }
      }
    #+end_src

    If you haven't done so, copy the default ~/etc/php/php.ini~ to
    ~/etc/webapps/nextcloud/php.ini~. Make a few configuration changes
    #+begin_src conf
      ;open_basedir = /var/lib/nextcloud/data:/var/lib/nextcloud/apps:/tmp:/usr/share/webapps/nextcloud:/etc/webapps/nextcloud:/data/nextcloud:/dev/urandom:/usr/lib/php/modules:/var/log/nextcloud:/proc/meminfo
      max_execution_time = 360
      memory_limit = 512M
      post_max_size = 256M
      upload_max_filesize = 256M
      extension=bcmath
      extension=bz2
      extension=exif
      extension=gd
      extension=iconv
      extension=imagick
      extension=intl
      extension=pdo_mysql
      date.timezone = Europe/Zurich
    #+end_src

    Make sure the Nextcloud dedicated ~php.ini~ is actually used, by
    setting the environment variable ~NEXTCLOUD_PHP_CONFIG~
    #+begin_src shell
      export NEXTCLOUD_PHP_CONFIG=/etc/webapps/nextcloud/php.ini
    #+end_src

    As a privacy and security precaution also create the dedicated
    directory for session data
    #+begin_src shell
      install --owner=nextcloud --group=nextcloud --mode=700 -d /var/lib/nextcloud/sessions
    #+end_src

    There are a few application servers compatible with nextcloud, I
    usually choose ~php-fpm~, but feel free to consult the Arch wiki
    for other options. Begin with copying the ~/etc/php/php.ini~ to a
    dedicated ~/etc/php/php-fpm.ini~ file (make sure it is owned and
    only writeable by root). Here we set the Zend OPcache by
    uncommenting the following lines
    #+begin_src conf
      zend_extension=opcache
      opcache.enable=1
      opcache.memory_consumption=128
      opcache.interned_strings_buffer=8
      opcache.max_accelerated_files=10000
      opcache.revalidate_freq=1
      opcache.save_comments=1
    #+end_src

    Finally set up a pool file for php-fpm in
    ~/etc/php/php-fpm.d/nextcloud.conf~ (again, make sure it is owned
    and only writeable by root). It is responsible for spawning
    dedicated processes for the Nextcloud application. Make sure the
    ~php_value[...]~ and ~php_flag[...]~ correspond to the settings in
    ~/etc/webapps/nextcloud/php.ini~ or they might be overwritten unintendedly
    #+begin_src conf
      [nextcloud]
      user = nextcloud
      group = nextcloud

      listen = /run/php-fpm/nextcloud.sock
      listen.owner = nextcloud
      listen.group = http
      listen.mode = 0660

      pm = dynamic
      pm.max_children = 8
      pm.start_servers = 2
      pm.min_spare_servers = 1
      pm.max_spare_servers = 3

      access.log = /var/log/php-fpm/$pool.access.log
      access.format = "%{%Y-%m-%dT%H:%M:%S%z}t %R: \"%m %r%Q%q\" %s %f %{milli}d %{kilo}M %C%%"

      chdir = /usr/share/webapps/$pool
      env[HOSTNAME] = $HOSTNAME
      env[PATH] = /usr/local/bin:/usr/bin
      env[TMP] = /tmp
      env[TMPDIR] = /tmp
      env[TEMP] = /tmp

      php_value[date.timezone] = Europe/Zurich
      #php_value[open_basedir] = /var/lib/$pool:/tmp:/usr/share/webapps/$pool:/etc/webapps/$pool:/data/$pool:/dev/urandom:/usr/lib/php/modules:/var/log/$pool:/proc/meminfo

      php_value[session.save_path] = /var/lib/$pool/sessions
      php_value[session.gc_maxlifetime] = 21600
      php_value[session.gc_divisor] = 500
      php_value[session.gc_probability] = 1

      php_flag[expose_php] = false
      php_value[post_max_size] = 256M
      php_value[upload_max_filesize] = 256M

      php_flag[output_buffering] = 4096
      php_value[max_input_time] = 60
      php_value[max_execution_time] = 360

      php_value[memory_limit] = 512M

      php_value[apc.ttl] = 7200
      php_flag[apc.enable_cli] = 1

      php_value[extension] = bcmath
      php_value[extension] = bz2
      php_value[extension] = exif
      php_value[extension] = gd
      php_value[extension] = gmp
      php_value[extension] = iconv
      php_value[extension] = imagick
      php_value[extension] = intl
      php_value[extension] = pdo_mysql
      php_value[extension] = zip
    #+end_src

    The application server is run as a systemd service. To make the
    configurations take, we need to override the default command run
    by systemd by means of a drop-in file
    ~/etc/systemd/system/php-fpm.service.d/override.conf~
    #+begin_src conf
      [Service]
      ExecStart=
      ExecStart=/usr/bin/php-fpm --nodaemonize --fpm-config /etc/php/php-fpm.conf --php-ini /etc/php/php-fpm.ini
      ReadWritePaths=/usr/share/webapps/nextcloud
      ReadWritePaths=/var/lib/nextcloud
      ReadWritePaths=/etc/webapps/nextcloud/config

      ReadWritePaths=/data/nextcloud
    #+end_src

    The access log might not exist, so when you try to start the
    php-fpm service with ~sudo systemctl start php-fpm~ and you get an
    error, try
    #+begin_src shell
      sudo mkdir /var/log/php-fpm
    #+end_src

    And finally start and enable the service with
    #+begin_src shell
      sudo systemctl start php-fpm
      sudo systemctl enable php-fpm
    #+end_src

    In this example, I've created another ~/data~ partition and a
    folder ~/data/nextcloud~ on it, which will act as data directory
    for nextcloud, additionally we have to create a few folders in
    nextcloud's installation directory.
    #+begin_src shell
      sudo mkdir -p /data/nextcloud
      sudo chmod 770 /data/nextcloud
      sudo chown nextcloud:nextcloud /data/nextcloud

      sudo mkdir -p /usr/share/webapps/nextcloud/{apps,data}
      sudo chmod 755 /usr/share/webapps/nextcloud/{apps,data}
      sudo chown nextcloud:nextcloud /usr/share/webapps/nextcloud/{apps,data}
    #+end_src

    This should be enough for you to visit your nextcloud domain and
    continue the setup on the web server.

    Should you have problems with adding phone numbers to your
    accounts, you probably have to add ~default_phone_region~ to your
    ~/etc/webapps/nextcloud/config/config.php~
    #+begin_src conf
      <?php
      $CONFIG = array (
        ...
        'default_phone_region' => 'CH',
        ...
        );
    #+end_src

*** TODO Mail server
    
*** Mail (mu4e and mbsync)
    It is always nice to have an alternate way of reading emails
    #+begin_src shell
      sudo pacman -S openssl isync
    #+end_src

    #+begin_src shell
      yay -S mu cyrus-sasl-xoauth2-git oauth2token
    #+end_src

    For registering a Microsoft IMAP account in isync, use
    ~oauth2token~.  For this create a directory in
    ~~/.config/oauth2token/microsoft~ and create the files
    ~config.json~ and ~scopes.json~

    #+begin_src conf
      // config.json
      {
          "web": {
              "client_id": "08162f7c-0fd2-4200-a84a-f25a4db0b584",
              "client_secret": "TxRBilcHdC6WGBee]fs?QR:SJ8nI[g82",
              "auth_uri": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize",
              "token_uri": "https://login.microsoftonline.com/common/oauth2/v2.0/token"
          }
      }
    #+end_src

    #+begin_src conf
      // scopes.json
      ["https://outlook.office.com/POP.AccessAsUser.All", "https://outlook.office.com/IMAP.AccessAsUser.All", "https://outlook.office.com/SMTP.Send"]
    #+end_src

    Then you can register an account with the provider

    #+begin_src shell
      oauth2create microsoft <my_account_name>
    #+end_src

    Once registered, you can receive OAuth2 tokens using
    #+begin_src shell
      oauth2get microsoft <my_account_name>
    #+end_src

*** Password utilities
    Pass and enpass are password managers I like most so far
    #+begin_src shell
      sudo pacman -S pass pass-otp zbar
      yay -S enpass-bin
    #+end_src

    Set up a new GPG key or import one from another machine
    (see ~../bin/gpg_import~ and ~../bin/gpg_export~ scripts).

    In order to sync between them, I use ~pass-import~
    #+begin_src shell
      cd ~/local
      git clone git@github.com:phdenzel/pass-import.git
      cd pass-import
      python3 setup.py install --user
    #+end_src

*** Utilities
    Calculator, clipboard, and screenshot programs
    #+begin_src shell
      sudo pacman -S colordiff qalculate-gtk xclip xsel scrot
    #+end_src

*** Media programs
    Office suite, document viewer, music and media players
    #+begin_src shell
      sudo pacman -S libreoffice-still zathura zathura-pdf-mupdf calibre lollypop easytag gst-plugins-base gst-plugins-good gst-plugin-ugly mpv celluloid mkvtoolnix-cli perl-image-exiftool
    #+end_src

    and the spotify client
    #+begin_src shell
      yay -S ffmpeg-compat-57 spotify
      sudo pacman -S zenity 
    #+end_src

*** Graphics
    Graphics editors
    #+begin_src shell
      sudo pacman -S gimp inkscape openscad
    #+end_src

*** Fonts
    #+begin_src shell
      sudo pacman -S terminus-font ttf-dejavu ttf-fira-mono ttf-fira-sans ttf-roboto ttf-roboto-mono adobe-source-code-pro-fonts adobe-source-sans-fonts ttf-hack ttf-inconsolata ttf-ubuntu-font-family ttf-font-awesome
    #+end_src

    #+begin_src shell
      yay -S ttf-all-the-icons ttf-weather-icons
    #+end_src

    Set the tty font using
    #+begin_src shell
      echo "FONT=ter-132b" | sudo tee /etc/vconsole.conf
    #+end_src

    You could also try to convert your own psf fonts using
    #+begin_src shell
      yay -S otf2bdf bdf2psf
      ~/local/bin/psf_from_ttf DejaVuSansMono 16 96
      sudo cp DejaVuSansMono.psf /usr/share/kbd/consolefonts/
      fc-cache -v -f
      echo "FONT=DejaVuSansMono.psf" | sudo tee /etc/vconsole.conf
    #+end_src

    and add the consolefont hook to the initcpio
    #+begin_src shell
      sudo sed -i 's/keyboard/consolefont keyboard/' /etc/mkinitcpio.conf
      sudo mkinitcpio -P
    #+end_src

**** Optional: GRUB fonts

  Additionally, I like to change the font in GRUB to the same font I use in the tty
  #+begin_src shell
    sudo grub-mkfont -o /efi/grub/fonts/ter-32b.pf2 /usr/share/fonts/misc/ter-u32b.otb
  #+end_src

  Once the font is created, add the following line to ~/etc/defaults/grub~
  #+begin_src conf
    GRUB_FONT=/efi/grub/fonts/ter-32b.pf2
  #+end_src

  Again, once you're done modifying your GRUB settings, regenerate the
  GRUB configuration
  #+begin_src shell
    grub-mkconfig -o /efi/grub/grub.cfg
  #+end_src

*** Device software
    Software for the GK6X keyboard
    #+begin_src shell
      yay -S gk6x-bin
    #+end_src

*** Virtualization
    I prefer ~virt-manager~ much over ~virtualbox~ (see ~arch_vm.sh~
    for easy initialization of VMs)
    #+begin_src shell
      sudo pacman -S virt-manager qemu qemu-arch-extra edk2-ovmf vde2 bridge-utils  # ebtables dnsmasq openbsd-netcat
      sudo systemctl enable --now libvirtd.service
    #+end_src

    For some linux distros, the default virtual network doesn't work
    #+begin_src shell
      sudo virsh net-define br10.xml
      sudo virsh net-start br10
      sudo virsh net-autostart br10
    #+end_src
    where
    #+begin_src xml
      <network>
        <name>br10</name>
        <forward mode='nat'>
          <nat>
            <port start='1024' end='65535'/>
          </nat>
        </forward>
        <bridge name='br10' stp='on' delay='0'/>
        <ip address='192.168.30.1' netmask='255.255.255.0'>
          <dhcp>
            <range start='192.168.30.50' end='192.168.30.200'/>
          </dhcp>
        </ip>
      </network>
    #+end_src

    If you're using firewalld, make sure to enable the libvirt service in the libvirt zone:
    #+begin_src shell
      sudo firewall-cmd --add-service libvirt --zone=libvirt
    #+end_src



* Maintenance

  With arch, I and probably most people use the package managers
  ~pacman~ and ~yay~.

  ~pacman~'s three major flags are ~-S~ for sync, ~-R~ for remove, and
  ~-Q~ for query. ~yay~ works mostly analogously to ~pacman~, except
  there is no need to use ~sudo~. The following list contains my most
  frequently used commands:

  - Install a package
    #+begin_src shell
      sudo pacman -S <pkg>
    #+end_src

  - Search a package in the repositories
    #+begin_src shell
      sudo pacman -Ss <search>
    #+end_src

  - Update packages
    #+begin_src shell
      sudo pacman -Syu
    #+end_src
    or
    #+begin_src shell
      yay
    #+end_src

  - Refresh mirrors
    #+begin_src shell
      sudo pacman -Syyu
    #+end_src

  - Uninstall
    #+begin_src shell
      sudo pacman -Rsc <pkg>
    #+end_src

  - List installed packages
    #+begin_src shell
      sudo pacman -Qe
    #+end_src

  - Clean unused cache (add another ~c~ to clean entire cache)
    #+begin_src shell
      sudo pacman -Sc
    #+end_src

  - Check/list orphan packages
    #+begin_src shell
      pacman -Qtdq
    #+end_src

  - Remove orphan packages
    #+begin_src shell
      sudo pacman -Rns $(pacman -Qtdq)
    #+end_src

  - List upgradable packages
    #+begin_src shell
      yay -Pu
    #+end_src

  - Remove unused dependencies
    #+begin_src shell
      yay -Yc
    #+end_src


  Besides updating, refreshing, and cache cleaning packages, there are
  only a couple more things to do for system maintenance:

  - Check for failed systemd services
    #+begin_src shell
      systemctl --failed
    #+end_src

  - Clean the cache (either selectively or the entire cache)
    #+begin_src shell
      rm -rf ~/.cache/*
    #+end_src

  - Check log files
    #+begin_src shell
      sudo journalctl -p 3 -xb
    #+end_src

  - Clean the journal up to the last 2 weeks
    #+begin_src shell
      sudo journalctl --vacuum-time=2weeks
    #+end_src
